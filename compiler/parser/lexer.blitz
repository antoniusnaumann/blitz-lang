struct Lexer {
	// TODO: this should become an iterator or be byte indexed string that remembers char position instead of a list of chars
	source List(Rune)
	index  Int
}

fn new_lexer(source String) Lexer {
	Lexer(source: source.chars(), index: 0)
}

fn new_lexer(source List(Rune)) Lexer {
	Lexer(source:, index: 0)
}


fn lex(source String) List(Token) {
	var lexer = new_lexer(source)
	lexer.mut.lex()
}

fn lex(mut lexer Lexer) List(Token) {
	var tokens = []
	var token = lexer.mut.next()

	while token != none {
		tokens ++= token		
		token = lexer.mut.next()
	}
		
	tokens
}

fn reset(mut lexer Lexer) {
	lexer.index = 0
}

fn next(mut lexer Lexer) Option(Token) {
	lexer.mut.skip_space()
	if lexer.source.len() <= lexer.index {
		none
	} else {
		let start = lexer.index
		let ch = lexer.curr()
		lexer.mut.advance()

		let kind = switch ch {
			'+' {
				switch lexer.curr() {
					'+' {
						lexer.mut.advance()
						switch lexer.curr() {
							'=' { lexer.mut.up(concat_assign) }
							else { concat }
						}
					}
					'=' { lexer.mut.up(add_assign) }
					else { add }
				}
			}
			'-' {
				switch lexer.curr() {
					'=' { lexer.mut.up(sub_assign) }
					else { sub }
				}
			}
			'*' {
				switch lexer.curr() {
					'=' { lexer.mut.up(mul_assign) }
					else { mul }
				}
			}
			'/' {
				switch lexer.curr() {
					'/' {
						lexer.mut.skip_comment()
						comment
					}
					'=' { lexer.mut.up(div_assign) }
					else { div }
				}
			}
			'%' {
				switch lexer.curr() {
					'=' { lexer.mut.up(rem_assign) }
					else { rem }
				}
			}
			'=' {
				switch lexer.curr() {
					'=' { lexer.mut.up(eq) }
					else  { assign }
				}
			}
			'<' {
				switch lexer.curr() {
					'=' { lexer.mut.up(le) }
					else { lt }
				}
			}
			'>' {
				switch lexer.curr() {
					'=' { lexer.mut.up(ge) }
					else { gt }
				}
			}
			'!' {
				switch lexer.curr() {
					'=' { lexer.mut.up(ne) }
					else { not }
				}
			}
			'(' { lparen }
			')' { rparen }
			'[' { lbracket }
			']' { rbracket }
			'{' { lbrace }
			'}' { rbrace }
			',' { comma }
			'.' { dot }
			':' {
				switch lexer.curr() {
					':' { lexer.mut.up(path) }
					else { colon }
				}
			}
			';' { semicolon }
			'|' { pipe }
			'\n' { newline }
			'\0' { none }
			'"' {
				lexer.mut.skip_str()
				str
			}
			'\'' {
				lexer.mut.skip_ch()
				char
			}
			else {
				if ch >= 'a' and ch <= 'z' {
					lexer.mut.skip_ident()
					let name = lexer.substr(start, lexer.index)
					switch name {
						"struct" { struct_ }
						"union" { union_ }
						"actor" { actor_ }
						"alias" { alias_ }
						"fn" { fn_ }
						"pub" { pub_ }
					"let" { let_ }
					"var" { var_ }
					"mut" { mut_ }
						"for" { for_ }
						"while" { while_ }
						"if" { if_ }
						"else" { else_ }
						"switch" { switch_ }
						"as" { as_ }
						"test" { test_ }
						"assert" { assert_ }
						"break" { break_ }
						"continue" { continue_ }
						"return" { return_ }
						"and" { and_ }
						"or" { or_ }
						"async" { async_ }
						"await" { await_ }
						"try" { try_ }
						"catch" { catch_ }
						"raise" { raise_ }
						else { ident }
					}
				} else if ch >= 'A' and ch <= 'Z' {
					lexer.mut.skip_ident()
					type
				} else if ch >= '0' and ch <= '9' {
					lexer.mut.skip_num()
				} else { error }
			}
		}

		let span = Span(range: Range(begin: start, until: lexer.index), path: "TODO")
		Token(kind: kind, span: span)
	}
}

fn up(mut lexer Lexer, kind TokenKind) TokenKind {
	lexer.mut.advance()
	kind
}

fn advance(mut lexer Lexer) {
	lexer.index = lexer.index + 1
}

fn curr(mut lexer Lexer) Rune {
	if lexer.index < lexer.source.len() {
		lexer.source[lexer.index]
	} else {
		'\0'
	}
}

fn peekch(lexer Lexer) Rune {
	lexer.source[lexer.index + 1]
}

fn peekch(lexer Lexer, n Int) Rune {
	lexer.source[lexer.index + n]
}

fn substr(source List(Rune), span Span) String {
	substr(source, span.range)		
}

fn substr(lexer Lexer, start Int, until Int) String {
	substr(lexer.source, start, until)
}

fn substr(lexer Lexer, range Range) String {
	substr(lexer, range.begin, range.until)		
}

fn substr(lexer Lexer, span Span) String {
	substr(lexer, span.range)		
}

fn is_ident_char(lexer Lexer) Bool {
	let ch = lexer.curr()
	(ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or (ch >= '0' and ch <= '9') or ch == '_'
}

fn is_newline(lexer Lexer) Bool {
	let ch = lexer.curr()
	ch == '\n' or ch == '\r'
}

fn skip_space(mut lexer Lexer) {
	while lexer.curr() == ' ' or lexer.curr() == '\t' {
		lexer.mut.advance()
	}
}

fn skip_ident(mut lexer Lexer) {
	while lexer.is_ident_char() {
		lexer.mut.advance()
	}
}

fn skip_comment(mut lexer Lexer) {
	while !lexer.is_newline() {
		lexer.mut.advance()		
	}
}

fn skip_str(mut lexer Lexer) {
	var escape = false	
	while true {
		if escape {
			switch lexer.curr() {
				'(' { todo("Implement format strings") }
				else { } // escape sequences are generally handled in parser
			}
			escape = false
		} else {
			switch lexer.curr() {
				'"' {
					lexer.mut.advance()
					break
				}
				'\\' { escape = true }
				'\0' { break }
				else { }
			}
		}
		lexer.mut.advance()
	}
}

fn skip_ch(mut lexer Lexer) {
	var escape = false
	while true {
		if escape {
			escape = false
		} else {
			switch lexer.curr() {
				'\'' {
					lexer.mut.advance()
					break
				}
				'\\' { escape = true }
				'\0' { break }
				else { }
			}
		}
		lexer.mut.advance()
	}
}

fn skip_num(mut lexer Lexer) TokenKind {
	var dot = false	
	while true {
		let ch = lexer.curr()
		if !(ch >= '0' and ch <= '9') and ch != '.' { return if dot { float } else { int } }
		lexer.mut.advance()
		if ch == '.' {
			if dot { return float }
			if !(lexer.curr() >= '0' and lexer.curr() <= '9') { return int }
			dot = true
			lexer.mut.advance()
		}
	}
}
