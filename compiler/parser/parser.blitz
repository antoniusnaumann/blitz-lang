struct Parser {
    tokens List(Token)
    errors List(Error)
    source String
    index Int
}

fn new_parser(source String) Parser {
    mut lexer = new_lexer(source)
    let tokens = lexer.mut.lex()

    Parser(tokens: tokens, errors: [], source: source, index: 0)
}

fn parse(mut parser Parser) List(Definition) {
    mut result = []
    mut def = parser.mut.next()

    while def != none {
        result = result ++ def
        def = parser.mut.next()
    }

    result
}

fn next(mut parser Parser) Option(Definition) {
    mut def = none

    while def == none and !parser.eof() {
        def = parser.mut.parse_def()
    }

    def
}

fn tok(mut parser Parser) Token {
    if parser.tokens.len() > parser.index {
        let token = parser.tokens[parser.index]
    	parser.index = parser.index + 1
    	token
	} else {
	    Token(kind: eof, span: parser.last().span)
	}
}

fn peek(parser Parser) Token {
    if parser.tokens.len() > parser.index {
        parser.tokens[parser.index]
	} else {
	    Token(kind: eof, span: parser.last().span)
	}
}

fn last(parser Parser) Token {
    if parser.index == 0 {
        panic("Called 'last' before consuming a token!")
    }

    parser.tokens[parser.index - 1]
}

fn eof(parser Parser) Bool {
    parser.index >= parser.tokens.len()
}

fn span(parser Parser, from Token) Span {
    parser.span(from.span)
}

fn span(parser Parser, from Token, to Token) Span {
    parser.span(from.span, to.span)
}

fn span(parser Parser, from Span) Span {
    parser.span(from, parser.last().span)    
}

fn span(parser Parser, from Span, to Span) Span {
    from.merge(to)
}

fn expect(mut parser Parser, expected TokenKind) Option(Token) {
    let actual = parser.mut.tok()
    if expected != actual.kind {
        parser.mut.err("Unexpected token!")
        return none
    }

    actual
}

fn has(parser Parser, expected TokenKind) Bool {
    parser.peek().kind == expected
} 

fn err(mut parser Parser, msg String) {
   parser.errors = parser.errors ++ Error(span: parser.last().span, msg: msg)
} 

