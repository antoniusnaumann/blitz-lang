struct Parser {
    tokens List(Token)
    errors List(Error)
    index  Int
    source List(Rune)
}

fn new_parser(source String) Parser {
    let chars = source.chars()
    mut lexer = new_lexer(chars)
    let tokens = lexer.mut.lex()

    Parser(tokens:, errors: [], source: chars, index: 0)
}

fn parse(mut parser Parser) List(Definition) {
    mut result = []
    mut def = parser.mut.next()

    while def != none {
        result ++= def
        def = parser.mut.next()
    }

    result
}

fn parse(source String) List(Definition) {
    mut parser = new_parser(source)
    parser.mut.parse()
}

fn next(mut parser Parser) Option(Definition) {
    mut def = none

    parser.mut.skip_newlines()
    while def == none and !parser.eof() {
        def = parser.mut.parse_def()
    }

    def
}

fn tok(mut parser Parser) Token {
    if !parser.eof() {
        let token = parser.tokens[parser.index]
    	parser.index = parser.index + 1
    	token
	} else {
	    Token(kind: eof, span: parser.last().span)
	}
}

fn peek(parser Parser) Token {
    if !parser.eof() {
        parser.tokens[parser.index]
	} else {
	    Token(kind: eof, span: parser.last().span)
	}
}

fn peek(parser Parser, n Int) Token {
    let index = parser.index + n - 1    
    if index < parser.tokens.len() and index >= 0 {
        parser.tokens[index]
	} else {
	    Token(kind: eof, span: parser.last().span)
	}
}

fn last(parser Parser) Token {
    if parser.index == 0 {
        panic("Called 'last' before consuming a token!")
    }

    parser.tokens[parser.index - 1]
}

fn eof(parser Parser) Bool {
    parser.index >= parser.tokens.len()
}

fn span(parser Parser) Span {
    parser.peek().span
}

fn span(parser Parser, from Token) Span {
    parser.span(from.span)
}

fn span(parser Parser, from Token, to Token) Span {
    parser.span(from.span, to.span)
}

fn span(parser Parser, from Span) Span {
    parser.span(from, parser.last().span)    
}

fn span(parser Parser, from Span, to Span) Span {
    from.merge(to)
}

fn expect(mut parser Parser, expected TokenKind) Option(Token) {
    if expected != newline {
        parser.mut.skip_newlines()
    }
    let actual = parser.mut.tok()
    if expected != actual.kind {
        print("Expected")
        print(expected)
        print("Actual")
        print(actual.kind)
        parser.mut.err("Unexpected token!")
        return none
    }

    actual
}

fn accept(mut parser Parser, expected TokenKind) Option(Token) {
    parser.mut.skip_newlines()
    if parser.has(expected) {
        parser.mut.expect(expected)
    } else {
        none
    }
}

fn accept(mut parser Parser, expected List(TokenKind)) Option(Token) {
    parser.mut.skip_newlines()
    mut any = false
    for expected |kind| {
        if parser.has(kind) {
            any = true
            break
        } 
    }

    if any {
        parser.mut.tok()
    } else {
        none
    }
}

fn skip_newlines(mut parser Parser) {
    while parser.has(newline) or parser.has(comment) {
        parser.mut.tok()
    } 
}

fn has(parser Parser, expected TokenKind) Bool {
    parser.peek().kind == expected
}

fn err(mut parser Parser, msg String) {
    // TODO: for now, we panic, later we should maintain an error list
    print(parser.source.substr(parser.last().span))
    panic(msg)
    parser.errors ++= Error(span: parser.last().span, msg: msg)
} 

