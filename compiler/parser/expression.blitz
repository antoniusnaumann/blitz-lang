fn parse_precedence(mut parser Parser, lhs Expression, min_prec Int) Option(Expression) {
    mut left = lhs
    parser.mut.skip_newlines()
    print("ENTER PARSE PRECEDENCE")

    while true {
        let peek = parser.peek()
       
        if peek.kind == lbracket {
            parser.mut.expect(lbracket)
            parser.mut.skip_newlines()
            let index = parser.mut.parse_expression_bp(0)
            let end_bracket = parser.mut.expect(rbracket) else return none
            let span = left.span.merge(end_bracket.span)

            left = Index(target: left, index: index, span: span)
            continue
        }

        let op = switch peek.kind {
            Operator {
                print("OPERATOR")
                peek.kind
            }
            _ {
                print("NO OPERATOR -- BREAKING")
                break
            }
        }

        let prec = op.precedence()
        if prec.left < min_prec { break }

        parser.mut.next()
        parser.mut.skip_newlines()

        switch op {
            dot {
                switch parser.mut.accept(mut_) {
                    some {
                        left = Mut(target: left)
                        continue
                    }
                    none { }
                }

                let member = parser.mut.parse_ident()
                let span = left.span.merge(parser.span(member.span))

                switch parser.peek().kind {
                    lparen {
                        left = parser.mut.parse_member_call(left, member)
                    }
                    _ { left = Member(parent: left, member:, span:) }
                }
            }
            _ {
                let rhs = parser.mut.parse_expression_bp(prec.right)
                left = BinaryOp(op:, left:, right: rhs, span: lhs.span.merge(rhs.span))
            }
        }
    }

    left
}

fn parse_expression(mut parser Parser) Expression {
    parser.mut.parse_expression_bp(0)
}

fn parse_expression_bp(mut parser Parser, min_prec Int) Expression {
    print("ENTER PARSE EXPRESSION BP")
    parser.mut.skip_newlines()
    let token = parser.peek()

    // TODO: handle prefix operators here

    let lhs = switch token.kind {
        for_ { parser.mut.parse_for() }
        while_ { parser.mut.parse_while() }
        if_ { parser.mut.parse_if() }
        switch_ { parser.mut.parse_switch() }
        return_ {
            parser.mut.next()
            let peek = parser.peek()
            let span = token.span
            let emtpy_return = Return(expr: Block(statements: [], span:), span:)
            switch peek.kind {
                mut_ { empty_return }
                let_ { empty_return }
                semicolon { empty_return }
                rbrace { empty_return }
                rbracket { empty_return }
                rparen { empty_return }
                newline { empty_return }
                _ { Return(expr: parser.mut.parse_expression_bp(0), span: parser.span(span)) }
            }
        }
        continue_ {
            parser.mut.next()
            continue_
        }
        break_ {
            parser.mut.next()
            break_
        }
        assert_ {
            parser.mut.next()
            let condition = parser.mut.parse_expression_bp(0)
            let negated = UnaryOp(op: not, expr: condition, span: parser.span)
            let panic_arg = "Assertion failed"
            let panic_call = Call(name: "panic", args: [panic_arg], ufcs: false, span: parser.span)
            If(cond: negated, body: [panic_call], span: parser.span)
        }
        lbrace { parser.mut.parse_body() }
        ident {
            let span = token.span
            let name = parser.mut.parse_ident()
            switch parser.peek().kind {
                lparen { parser.mut.parse_call(name) }
                _ { name }
            }
        }
        type { parser.mut.parse_constructor() }
        lbracket { parser.mut.parse_list() }
        lparen { parser.mut.parse_group() }
        str { parser.mut.parse_string_lit() }
        ch { parser.mut.parse_char_lit() }
        num { parser.mut.parse_num_lit() }
        true_ { parser.mut.parse_bool_lit(true) }
        false_ { parser.mut.parse_bool_lit(false) }
        _ {
            print(token.kind)
            todo("Error handling: Illegal token for expression")
        }
    }

    print("BEFORE PARSE PREC")
    let expr = parser.mut.parse_precedence(lhs, min_prec)
    switch parser.mut.consume_assignment() {
        some {
            let assignment = some
            let right = parser.mut.parse_expression()
            right
            
            // Desugar compound assignments: a += b becomes a = a + b
            let desugared_right = switch assignment {
                add { BinaryOp(op: add, left: expr, right:, span: expr.span.merge(right.span)) }
                sub { BinaryOp(op: sub, left: expr, right:, span: expr.span.merge(right.span)) }
                mul { BinaryOp(op: mul, left: expr, right:, span: expr.span.merge(right.span)) }
                div { BinaryOp(op: div, left: expr, right:, span: expr.span.merge(right.span)) }
                rem { BinaryOp(op: rem, left: expr, right:, span: expr.span.merge(right.span)) }
                concat { BinaryOp(op: concat, left: expr, right:, span: expr.span.merge(right.span)) }
                plain { right }
            }

            Assignment(left: expr, right: desugared_right)
        }
        none { expr }
    }
}

union Assignment {
    add
    sub
    mul
    div
    rem
    concat
    plain
}

fn consume_assignment(mut parser Parser) Option(Assignment) {
    let token = parser.mut.accept([add_assign, sub_assign, mul_assign, div_assign, rem_assign, concat_assign, assign]) else return none
    
    switch token.kind {
        add_assign { add }
        sub_assign { sub }
        mul_assign { mul }
        div_assign { div }
        rem_assign { rem }
        concat_assign { concat }
        assign { plain }
        _ { panic("unreachable") }
    }
}

fn parse_for(mut parser Parser) Expression {
    todo("parse_for")
}

fn parse_while(mut parser Parser) Expression {
    todo("parse_while")
}

fn parse_if(mut parser Parser) Expression {
    todo("parse_if")
}

fn parse_switch(mut parser Parser) Expression {
    todo("parse_switch")
}

fn parse_member_call(mut parser Parser, target Expression, method Ident) Expression {
    todo("parse_member_call")
}

fn parse_call(mut parser Parser, name Ident) Expression {
    print("BEGIN PARSE CALL")
    let token = parser.mut.expect(lparen)
    mut args = []

    while !parser.has(rparen) {
        let param = parser.peek()
        switch param.kind {
            ident {
                switch parser.peek(2) {
                    colon {
                        let label = parser.mut.parse_ident() else panic("unreachable")
                        parser.mut.expect(colon) else panic("unreachable")
                        let init = switch parser.peek() {
                            comma { label }
                            _ { parser.mut.parse_expression() }
                        }
                        args ++= CallArg(label:, init:)
                    }
                    _ {
                        args ++= CallArg(label: none, init: parser.mut.parse_expression())
                    }
                }
            }
            _ {
                print("REGULAR PARAM")
                let init = parser.mut.parse_expression()
                print("AFTER PARAM")
                args ++= CallArg(label: none, init:)
            }
        }
        parser.mut.skip_newlines()
        parser.mut.accept(comma)

        parser.peek()        
    }
    parser.mut.expect(rparen)
    print("END PARSE CALL")
    Call(name:, args:, ufcs: false, span: parser.span(token))
}

fn parse_constructor(mut parser Parser) Expression {
    todo("parse_constructor")
}

fn parse_list(mut parser Parser) Expression {
    todo("parse_list")
}

fn parse_group(mut parser Parser) Expression {
    todo("parse_group")
}

fn parse_string_lit(mut parser Parser) String {
    let token = parser.mut.expect(str)
    parser.source.substr(token.span.range.begin + 1, token.span.range.until - 1)
}

fn parse_char_lit(mut parser Parser) Rune {
    todo("parse_char_lit")
}

fn parse_num_lit(mut parser Parser) Float {
    todo("parse_num_lit")
}

fn parse_bool_lit(mut parser Parser, value Bool) Expression {
    todo("parse_bool_lit")
}

fn parse_body(mut parser Parser) Block {
    todo("parse_body")
}
