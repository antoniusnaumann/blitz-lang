fn parse_precedence(mut parser Parser, lhs Expression, min_prec Int) Option(Expression) {
    var left = lhs
    parser.mut.skip_newlines()

    while true {
        let peek_ = parser.peek()
       
        if peek_.kind == lbracket {
            parser.mut.expect(lbracket)
            parser.mut.skip_newlines()
            let index = try parser.mut.parse_expression()
            let end_bracket = try parser.mut.expect(rbracket)
            let span = left.span.merge(end_bracket.span)

            left = Index(target: left, index:, span:)
            continue
        }

        let op = switch peek_.kind {
            Operator {
                peek_.kind
            }
            else {
                break
            }
        }

        let prec = op.precedence()
        if prec.left < min_prec { break }

        parser.mut.tok()
        parser.mut.skip_newlines()

        switch op {
            dot {
                switch parser.mut.accept(mut_) {
                    some {
                        left = Mut(expr: left, span: parser.span(), ufcs: true)
                        continue
                    }
                    none { }
                }
                switch parser.mut.accept(try_) {
                    some {
                        left = Try(expr: left, span: parser.span(), ufcs: true)
                        continue
                    }
                    none { }
                }
                let member = parser.mut.parse_ident()
                let span = left.span.merge(parser.span(member.span))

                switch parser.peek().kind {
                    lparen {
                        left = parser.mut.parse_member_call(left, member)
                    }
                    else {
                        left = Member(parent: left, member:, span:)
                    }
                }
            }
            else {
                let rhs = parser.mut.parse_expression_bp(prec.right)
                left = BinaryOp(op:, left:, right: rhs, span: lhs.span.merge(rhs.span))
            }
        }
    }

    left
}

fn parse_expression(mut parser Parser) Option(Expression) {
    parser.mut.parse_expression_bp(0)
}

fn parse_expression_bp(mut parser Parser, min_prec Int) Option(Expression) {
    parser.mut.skip_newlines()
    let token = parser.peek()

    let lhs = switch token.kind {
        // TODO: handle prefix operators here
        for_ { parser.mut.parse_for() }
        while_ { parser.mut.parse_while() }
        if_ { parser.mut.parse_if() }
        switch_ { parser.mut.parse_switch() }
        return_ {
            parser.mut.tok()
            let peek = parser.peek()
            let span = token.span
            let empty_return = Return(expr: Block(statements: [], span:), span:)
            switch peek.kind {
                var_ { empty_return }
                let_ { empty_return }
                semicolon { empty_return }
                rbrace { empty_return }
                rbracket { empty_return }
                rparen { empty_return }
                newline { empty_return }
                else { Return(expr: try parser.mut.parse_expression(), span: parser.span(span)) }
            }
        }
        continue_ { 
            parser.mut.tok()
            Continue(span: parser.span(token))
        }
        break_ {
            parser.mut.tok()
            Break(span: parser.span(token))
        }
        try_ {
            parser.mut.tok()
            Try(expr: try parser.mut.parse_expression(), span: parser.span(token), ufcs: false)
        }
        assert_ {
            parser.mut.tok()
            Assert(cond: try parser.mut.parse_expression(), span: parser.span(token), ufcs: false)
        }
        mut_ {
            parser.mut.tok()
            Mut(expr: try parser.mut.parse_expression(), span: parser.span(token), ufcs: false)
        }
        lbrace { try parser.mut.parse_body() }
        ident {
            let span = token.span
            let name = parser.mut.parse_ident()
            switch parser.peek().kind {
                lparen { parser.mut.parse_call(name) }
                else { name }
            }
        }
        type { parser.mut.parse_constructor() }
        lbracket { parser.mut.parse_list() }
        lparen { parser.mut.parse_group() }
        str { parser.mut.parse_string_lit() }
        char { parser.mut.parse_char_lit() }
        int { parser.mut.parse_int_lit() }
        float { parser.mut.parse_float_lit() }
        UnaryOperator {
            parser.mut.tok()
            let inner = try parser.mut.parse_expression()
            UnaryOp(op: it, expr: inner, span: parser.span(token))                   
        }
        else {
            print(token.kind)
            todo("Error handling: Illegal token for expression")
        }
    }

    let expr = parser.mut.parse_precedence(lhs, min_prec)
    switch parser.mut.consume_assignment() {
        some {
            let assignment = it
            let right = try parser.mut.parse_expression()
            
            // Desugar compound assignments: a += b becomes a = a + b
            let desugared_right = switch assignment {
                add { BinaryOp(op: add, left: expr, right:, span: expr.span.merge(right.span)) }
                sub { BinaryOp(op: sub, left: expr, right:, span: expr.span.merge(right.span)) }
                mul { BinaryOp(op: mul, left: expr, right:, span: expr.span.merge(right.span)) }
                div { BinaryOp(op: div, left: expr, right:, span: expr.span.merge(right.span)) }
                rem { BinaryOp(op: rem, left: expr, right:, span: expr.span.merge(right.span)) }
                concat { BinaryOp(op: concat, left: expr, right:, span: expr.span.merge(right.span)) }
                plain { right }
            }

            Assignment(left: expr, right: desugared_right)
        }
        none { expr }
    }
}

union Assignment {
    add
    sub
    mul
    div
    rem
    concat
    plain
}

fn consume_assignment(mut parser Parser) Option(Assignment) {
    let token = try parser.mut.accept([add_assign, sub_assign, mul_assign, div_assign, rem_assign, concat_assign, assign])
    
    switch token.kind {
        add_assign { add }
        sub_assign { sub }
        mul_assign { mul }
        div_assign { div }
        rem_assign { rem }
        concat_assign { concat }
        assign { plain }
        else { panic("unreachable") }
    }
}

fn parse_for(mut parser Parser) Option(For) {
    let kw = try parser.mut.expect(for_)
    let iter = try parser.mut.parse_expression()

    // TODO: implement implicit argument it
    try parser.mut.expect(pipe)
    let elem = try parser.parse_ident()
    try parser.mut.expect(pipe)

    let body = try parser.mut.parse_body()
    
    For(iter:, elem:, body:, span: parser.span(kw))
}

fn parse_while(mut parser Parser) Option(While) {
    let kw = try parser.mut.expect(while_)
    let cond = try parser.mut.parse_expression()
    let body = try parser.mut.parse_body()

    While(cond:, body:, span: parser.span(kw))
}

fn parse_if(mut parser Parser) Option(If) {
    let kw = try parser.mut.expect(if_)
    let cond = try parser.mut.parse_expression()
    let body = try parser.mut.parse_body()

    If(cond:, body:, span: parser.span(kw))
}

fn parse_switch(mut parser Parser) Option(Switch) {
    let token = try parser.mut.expect(switch_)
    let expr = try parser.mut.parse_expression()
    try parser.mut.expect(lbrace)
    parser.mut.skip_newlines()

    var cases = []
    while !parser.has(rbrace) {
        let case_start = parser.span()
        let label = try parser.mut.parse_switch_label()
        parser.mut.skip_newlines()
        let body = try parser.mut.parse_body()
        parser.mut.skip_newlines()

        cases ++= SwitchCase(label:, body:, span: parser.span(case_start))
    }
    parser.mut.expect(rbrace)

    Switch(cond: expr, cases:, span: parser.span(token))
}

fn parse_switch_label(mut parser Parser) Option(SwitchLabel) {
    switch parser.peek().kind {
        ident { try parser.mut.parse_ident() }
        type { try parser.mut.parse_type() }
        str { try parser.mut.parse_string_lit() }
        int { try parser.mut.parse_int_lit() }
        float { try parser.mut.parse_float_lit() }
        char { try parser.mut.parse_char_lit() }
        else_ {
            parser.mut.tok()
            default
        }
        else { parser.mut.err("Unexpected token for switch label!") }
    }
}

fn parse_member_call(mut parser Parser, target Expression, method Ident) Option(Call) {
    var call = parser.mut.parse_call(method)
    call.ufcs = true
    call.args = [CallArg(label: none, init: target)] ++ call.args
    call
}

fn parse_call(mut parser Parser, name Ident) Option(Call) {
    let token = parser.peek()
    let args = parser.mut.parse_args() 
    
    Call(name:, args:, ufcs: false, span: parser.span(token))
}

fn parse_constructor(mut parser Parser) Option(Constructor) {
    let token = parser.peek()
    let ty = try parser.mut.parse_type_ident()
    let args = try parser.mut.parse_args()

    Constructor(type: ty, args:, ufcs: false, span: parser.span(token))
}

fn parse_args(mut parser Parser) Option(List(CallArg)) {
    try parser.mut.expect(lparen)
    var args = []

    while !parser.has(rparen) {
        let param = parser.peek()
        switch param.kind {
            ident {
                switch parser.peek(2).kind {
                    colon {
                        let label = try parser.mut.parse_ident()
                        try parser.mut.expect(colon)
                        let init = switch parser.peek().kind {
                            comma { label }
                            rparen { label }
                            else { try parser.mut.parse_expression() }
                        }
                        args ++= CallArg(label:, init:)
                    }
                    else {
                        args ++= CallArg(label: none, init: try parser.mut.parse_expression())
                    }
                }
            }
            else {
                let init = try parser.mut.parse_expression()
                args ++= CallArg(label: none, init:)
            }
        }
        parser.mut.accept(comma)

        parser.peek()        
    }
    parser.mut.expect(rparen)

    args
}

fn parse_list(mut parser Parser) Option(List_) {
    let start = try parser.mut.expect(lbracket)
    var elems = []

    while !parser.has(rbracket) {
        parser.mut.skip_newlines()
        elems ++= parser.mut.parse_expression()
        parser.mut.accept(comma)
        parser.mut.skip_newlines()
    }
    parser.mut.expect(rbracket)

    List_(elems:, span: parser.span(start))
}

fn parse_group(mut parser Parser) Option(Expression) {
    let token = try parser.mut.expect(lparen)
    let expr = try parser.mut.parse_expression()
    try parser.mut.expect(rparen)

    Group(expr:, span: parser.span(token))
}

fn parse_string_lit(mut parser Parser) Option(Lit(String)) {
    let token = parser.mut.expect(str)
    let value = parser.source.substr(token.span.range.begin + 1, token.span.range.until - 1)

    Lit(value:, span: parser.span(token))
}

fn parse_char_lit(mut parser Parser) Option(Lit(Rune)) {
    let token = parser.mut.expect(char)
    let chars = parser.source.substr(token.span.range.begin + 1, token.span.range.until - 1).chars()
    let value = switch chars.len() {
        1 { chars[0] }
        2 {
            if chars[0] != '\\' {
                parser.mut.err("Invalid char length")
                return none
            }

            switch chars[1] {
                'n' { '\n' }
                'r' { '\r' }
                't' { '\t' }
                '0' { '\0' }
                '\\' { '\\' }
                '\'' { '\'' }
                'x' { todo("Hex lit") }
                'u' { todo("Unicode lit") }
                '(' { todo("Format strings") }
                else {
                    parser.mut.err("Invalid escape sequence")
                    return none
                }
            }
        }
        else {
            parser.mut.err("Invalid char length")
            return none
        }
    }

    Lit(value:, span: parser.span(token))
}

fn parse_int_lit(mut parser Parser) Option(Lit(Int)) {
    let token = parser.mut.expect(int)
    var index = token.span.range.begin
    var number = 0

    while index < token.span.range.until {
        number *= 10
        number += switch parser.source[index] {
            // TODO: replace with ASCII math
            '0' { 0 }
            '1' { 1 }
            '2' { 2 }
            '3' { 3 }
            '4' { 4 }
            '5' { 5 }
            '6' { 6 }
            '7' { 7 }
            '8' { 8 }
            '9' { 9 }
        }
        index += 1
    }

    Lit(value: number, span: parser.span(token))
}

fn parse_float_lit(mut parser Parser) Option(Lit(Float)) {
    todo("parse float lit")
}

fn parse_body(mut parser Parser) Option(Block) {
    try parser.mut.expect(lbrace)
    let first = parser.peek()
    var body = []
    while !parser.has(rbrace) {
        let statement = try parser.mut.parse_statement()
        body ++= statement
        parser.mut.accept(semicolon)
        parser.mut.skip_newlines()
    }
    parser.mut.expect(rbrace)

    Block(statements: body, span: parser.span(first))
}
