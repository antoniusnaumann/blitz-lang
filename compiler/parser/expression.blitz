fn parse_precedence(mut parser Parser, lhs Expression, min_prec Int) Option(Expression) {
    mut left = lhs
    parser.mut.skip_newlines()

    while true {
        let peek_ = parser.peek()
       
        if peek_.kind == lbracket {
            parser.mut.expect(lbracket)
            parser.mut.skip_newlines()
            let index = parser.mut.parse_expression() else return none
            let end_bracket = parser.mut.expect(rbracket) else return none
            let span = left.span.merge(end_bracket.span)

            left = Index(target: left, index: index, span: span)
            continue
        }

        let op = switch peek_.kind {
            Operator {
                peek_.kind
            }
            else {
                break
            }
        }

        let prec = op.precedence()
        if prec.left < min_prec { break }

        parser.mut.tok()
        parser.mut.skip_newlines()

        switch op {
            dot {
                switch parser.mut.accept(mut_) {
                    some {
                        left = Mut(expr: left, span: parser.span(), ufcs: true)
                        continue
                    }
                    none { }
                }
                let member = parser.mut.parse_ident()
                let span = left.span.merge(parser.span(member.span))

                switch parser.peek().kind {
                    lparen {
                        left = parser.mut.parse_member_call(left, member)
                    }
                    else {
                        left = Member(parent: left, member:, span:)
                    }
                }
            }
            else {
                let rhs = parser.mut.parse_expression_bp(prec.right)
                left = BinaryOp(op:, left:, right: rhs, span: lhs.span.merge(rhs.span))
            }
        }
    }

    left
}

fn parse_expression(mut parser Parser) Option(Expression) {
    parser.mut.parse_expression_bp(0)
}

fn parse_expression_bp(mut parser Parser, min_prec Int) Option(Expression) {
    parser.mut.skip_newlines()
    let token = parser.peek()

    let lhs = switch token.kind {
        // TODO: handle prefix operators here
        for_ { parser.mut.parse_for() }
        while_ { parser.mut.parse_while() }
        if_ { parser.mut.parse_if() }
        switch_ { parser.mut.parse_switch() }
        return_ {
            parser.mut.tok()
            let peek = parser.peek()
            let span = token.span
            let emtpy_return = Return(expr: Block(statements: [], span:), span:)
            switch peek.kind {
                mut_ { empty_return }
                let_ { empty_return }
                semicolon { empty_return }
                rbrace { empty_return }
                rbracket { empty_return }
                rparen { empty_return }
                newline { empty_return }
                else { Return(expr: parser.mut.parse_expression() else return none, span: parser.span(span)) }
            }
        }
        continue_ { 
            parser.mut.tok()
            Continue(span: parser.span(token))
        }
        break_ {
            parser.mut.tok()
            Break(span: parser.span(token))
        }
        assert_ {
            parser.mut.tok()
            let condition = parser.mut.parse_expression()
            Assert(cond: condition, span: parser.span(token), ufcs: false)
        }
        lbrace { parser.mut.parse_body() else return none }
        ident {
            let span = token.span
            let name = parser.mut.parse_ident()
            switch parser.peek().kind {
                lparen { parser.mut.parse_call(name) }
                else { name }
            }
        }
        type { parser.mut.parse_constructor() }
        lbracket { parser.mut.parse_list() }
        lparen { parser.mut.parse_group() }
        str { parser.mut.parse_string_lit() }
        ch { parser.mut.parse_char_lit() }
        int { parser.mut.parse_int_lit() }
        float { parser.mut.parse_float_lit() }
        true_ {
            parser.mut.tok()
            Lit(value: true, span: parser.span(token))
        }
        false_ {
            parser.mut.tok()
            Lit(value: true, span: parser.span(token))
        }
        UnaryOperator {
            parser.mut.tok()
            let inner = parser.mut.parse_expression() else return none
            UnaryOp(op: it, expr: inner, span: parser.span(token))                   
        }
        else {
            print(token.kind)
            todo("Error handling: Illegal token for expression")
        }
    }

    let expr = parser.mut.parse_precedence(lhs, min_prec)
    switch parser.mut.consume_assignment() {
        some {
            let assignment = it
            let right = parser.mut.parse_expression() else return none
            
            // Desugar compound assignments: a += b becomes a = a + b
            let desugared_right = switch assignment {
                add { BinaryOp(op: add, left: expr, right:, span: expr.span.merge(right.span)) }
                sub { BinaryOp(op: sub, left: expr, right:, span: expr.span.merge(right.span)) }
                mul { BinaryOp(op: mul, left: expr, right:, span: expr.span.merge(right.span)) }
                div { BinaryOp(op: div, left: expr, right:, span: expr.span.merge(right.span)) }
                rem { BinaryOp(op: rem, left: expr, right:, span: expr.span.merge(right.span)) }
                concat { BinaryOp(op: concat, left: expr, right:, span: expr.span.merge(right.span)) }
                plain { right }
            }

            Assignment(left: expr, right: desugared_right)
        }
        none { expr }
    }
}

union Assignment {
    add
    sub
    mul
    div
    rem
    concat
    plain
}

fn consume_assignment(mut parser Parser) Option(Assignment) {
    let token = parser.mut.accept([add_assign, sub_assign, mul_assign, div_assign, rem_assign, concat_assign, assign]) else return none
    
    switch token.kind {
        add_assign { add }
        sub_assign { sub }
        mul_assign { mul }
        div_assign { div }
        rem_assign { rem }
        concat_assign { concat }
        assign { plain }
        else { panic("unreachable") }
    }
}

fn parse_for(mut parser Parser) Option(For) {
    let kw = parser.mut.expect(for_) else return none
    let iter = parser.mut.parse_expression() else return none

    // TODO: implement implicit argument it
    parser.mut.expect(pipe) else return none
    let elem = parser.parse_ident() else return none
    parser.mut.expect(pipe) else return none

    let body = parser.mut.parse_body() else return none
    
    For(iter:, elem:, body:, span: parser.span(kw))
}

fn parse_while(mut parser Parser) Option(While) {
    let kw = parser.mut.expect(while_) else return none
    let cond = parser.mut.parse_expression() else return none
    let body = parser.mut.parse_body() else return none

    While(cond:, body:, span: parser.span(kw))
}

fn parse_if(mut parser Parser) Option(If) {
    let kw = parser.mut.expect(if_) else return none
    let cond = parser.mut.parse_expression() else return none
    let body = parser.mut.parse_body() else return none

    If(cond:, body:, span: parser.span(kw))
}

fn parse_switch(mut parser Parser) Option(Switch) {
    let token = parser.mut.expect(switch_) else return none
    let expr = parser.mut.parse_expression() else return none
    parser.mut.expect(lbrace) else return none
    parser.mut.skip_newlines()

    mut cases = []
    while !parser.has(rbrace) {
        let case_start = parser.span()
        let label = parser.mut.parse_switch_label() else return none
        parser.mut.skip_newlines()
        let body = parser.mut.parse_body() else return none
        parser.mut.skip_newlines()

        cases ++= SwitchCase(label:, body:, span: parser.span(case_start))
    }
    parser.mut.expect(rbrace)

    Switch(cond: expr, cases:, span: parser.span(token))
}

fn parse_switch_label(mut parser Parser) Option(SwitchLabel) {
    switch parser.peek().kind {
        ident { parser.mut.parse_ident() else return none }
        type { parser.mut.parse_type() else return none }
        else_ {
            parser.mut.tok()
            default
        }
        else { parser.mut.err("Unexpected token for switch label!") }
    }
}

fn parse_member_call(mut parser Parser, target Expression, method Ident) Option(Call) {
    mut call = parser.mut.parse_call(method)
    call.ufcs = true
    call.args = [CallArg(label: none, init: target)] ++ call.args
    call
}

fn parse_call(mut parser Parser, name Ident) Option(Call) {
    let token = parser.peek()
    let args = parser.mut.parse_args() 
    
    Call(name:, args:, ufcs: false, span: parser.span(token))
}

fn parse_constructor(mut parser Parser) Option(Constructor) {
    let token = parser.peek()
    let ty = parser.mut.parse_type_ident() else return none
    let args = parser.mut.parse_args() else return none

    Constructor(type: ty, args:, ufcs: false, span: parser.span(token))
}

fn parse_args(mut parser Parser) Option(List(CallArg)) {
    parser.mut.expect(lparen) else return none
    mut args = []

    while !parser.has(rparen) {
        let param = parser.peek()
        switch param.kind {
            ident {
                switch parser.peek(2).kind {
                    colon {
                        let label = parser.mut.parse_ident() else panic("unreachable")
                        parser.mut.expect(colon) else panic("unreachable")
                        let init = switch parser.peek().kind {
                            comma { label }
                            rparen { label }
                            else { parser.mut.parse_expression() else return none }
                        }
                        args ++= CallArg(label:, init:)
                    }
                    else {
                        args ++= CallArg(label: none, init: parser.mut.parse_expression() else return none)
                    }
                }
            }
            else {
                let init = parser.mut.parse_expression() else return none
                args ++= CallArg(label: none, init:)
            }
        }
        parser.mut.accept(comma)

        parser.peek()        
    }
    parser.mut.expect(rparen)

    args
}

fn parse_list(mut parser Parser) Option(List_) {
    let start = parser.mut.expect(lbracket) else return none
    mut elems = []

    while !parser.has(rbracket) {
        parser.mut.skip_newlines()
        elems ++= parser.mut.parse_expression()
        parser.mut.accept(comma)
        parser.mut.skip_newlines()
    }
    parser.mut.expect(rbracket)

    List_(elems:, span: parser.span(start))
}

fn parse_group(mut parser Parser) Option(Expression) {
    todo("parse_group")
}

fn parse_string_lit(mut parser Parser) Option(Lit(String)) {
    let token = parser.mut.expect(str)
    let value = parser.source.substr(token.span.range.begin + 1, token.span.range.until - 1)

    Lit(value:, span: parser.span(token))
}

fn parse_char_lit(mut parser Parser) Option(Lit(Rune)) {
    todo("parse_char_lit")
}

fn parse_int_lit(mut parser Parser) Option(Lit(Int)) {
    let token = parser.mut.expect(int)
    mut index = token.span.range.begin
    mut number = 0

    while index < token.span.range.until {
        number *= 10
        number += switch parser.source[index] {
            // TODO: replace with ASCII math
            '0' { 0 }
            '1' { 1 }
            '2' { 2 }
            '3' { 3 }
            '4' { 4 }
            '5' { 5 }
            '6' { 6 }
            '7' { 7 }
            '8' { 8 }
            '9' { 9 }
        }
        index += 1
    }

    Lit(value: number, span: parser.span(token))
}

fn parse_float_lit(mut parser Parser) Option(Lit(Float)) {
    todo("parse float lit")
}

fn parse_body(mut parser Parser) Option(Block) {
    parser.mut.expect(lbrace) else return none
    let first = parser.peek()
    mut body = []
    while !parser.has(rbrace) {
        let statement = parser.mut.parse_statement() else return none
        body ++= statement
        parser.mut.accept(semicolon)
        parser.mut.skip_newlines()
    }
    parser.mut.expect(rbrace)

    Block(statements: body, span: parser.span(first))
}
