fn parse_precedence(mut parser Parser, mut lhs Expression, min_prec Int) Option(Expression) {
    parser.mut.skip_newlines()
    print("ENTER PARSE PRECEDENCE")

    while true {
        let peek = parser.peek()

        if peek.kind == lbracket {
            parser.mut.expect(lbracket)
            parser.mut.skip_newlines()
            let index = parser.mut.parse_expression_bp(0)
            let end_bracket = parser.mut.expect(rbracket) else return none
            let span = lhs.span.merge(end_bracket.span)

            lhs = Index(target: lhs, index: index, span: span)
            continue
        }

        let op = switch peek.kind {
            Operator { peek.kind }
            _ { break }
        }

        let prec = op.precedence()
        if prec.left < min_prec { break }

        parser.mut.next()
        parser.mut.skip_newlines()

        switch op {
            member {
                switch parser.mut.accept(mut_) {
                    some {
                        lhs = Mut(target: lhs)
                        continue
                    }
                    none { }
                }

                let member = parser.mut.parse_ident()
                let span = lhs.span.merge(parser.span(member.span))

                switch parser.peek().kind {
                    lparen {
                        lhs = parser.mut.parse_member_call(lhs, member)
                    }
                    _ { lhs = Member(parent: lhs, member:, span:) }
                }
            }
            _ {
                let rhs = parser.mut.parse_expression_bp(prec.right)
                lhs = BinaryOp(op:, left: lhs, right: rhs, span: lhs.span.merge(rhs.span))
            }
        }
    }
}

fn parse_expression(mut parser Parser) Expression {
    parser.mut.parse_expression_bp(0)
}

fn parse_expression_bp(mut parser Parser, min_prec Int) Expression {
    print("ENTER PARSE EXPRESSION BP")
    parser.mut.skip_newlines()
    let token = parser.peek()

    // TODO: handle prefix operators here

    let lhs = switch token.kind {
        for_ { parser.mut.parse_for() }
        while_ { parser.mut.parse_while() }
        if_ { parser.mut.parse_if() }
        switch_ { parser.mut.parse_switch() }
        return_ {
            parser.mut.next()
            let peek = parser.peek()
            let span = token.span
            let emtpy_return = Return(expr: Block(statements: [], span:), span:)
            switch peek.kind {
                mut_ { empty_return }
                let_ { empty_return }
                semicolon { empty_return }
                rbrace { empty_return }
                rbracket { empty_return }
                rparen { empty_return }
                newline { empty_return }
                _ { Return(expr: parser.mut.parse_expression_bp(0), span: parser.span(span)) }
            }
        }
        continue_ {
            parser.mut.next()
            continue_
        }
        break_ {
            parser.mut.next()
            break_
        }
        assert_ {
            parser.mut.next()
            let condition = parser.mut.parse_expression_bp(0)
            let negated = UnaryOp(op: not, expr: condition, span: parser.span)
            let panic_arg = "Assertion failed"
            let panic_call = Call(name: "panic", args: [panic_arg], ufcs: false, span: parser.span)
            If(cond: negated, body: [panic_call], span: parser.span)
        }
        lbrace { parser.mut.parse_body() }
        ident {
            let span = token.span
            let name = parser.mut.parse_ident()
            switch parser.peek().kind {
                lparen { parser.mut.parse_call(name) }
                _ { Ident(name:, span:) }
            }
        }
        type { parser.mut.parse_constructor() }
        lbracket { parser.mut.parse_list() }
        lparen { parser.mut.parse_group() }
        str { parser.mut.parse_string_lit() }
        ch { parser.mut.parse_char_lit() }
        num { parser.mut.parse_num_lit() }
        true_ { parser.mut.parse_bool_lit(true) }
        false_ { parser.mut.parse_bool_lit(false) }
        _ { todo("Error handling: Illegal token for expression") }
    }

    let expr = self.parse_precedence(lhs, min_prec)
    switch parser.mut.consume_assignment() {
        some {
            let right = parser.mut.parse_expression()
            // TODO LLM: desugar compound assignment as seen in parser.rs. but don't use Lval, we will validate that expr is a valid lval later

            Assignment(left: expr, right:)
        }
        none { expr }
    }
}

union Assignment {
    add
    sub
    mul
    div
    rem
    concat
    plain
}

fn consume_assignment(mut parser Parser) Option(Assignment) {
    let token = parser.mut.accept([add_assign, sub_assign, mul_assign, div_assign, rem_assign, concat_assign, assign]) else return none
    
    switch token.kind {
        add_assign { add }
        sub_assign { sub }
        mul_assign { mul }
        div_assign { div }
        rem_assign { rem }
        concat_assign { concat }
        assign { plain }
        _ { panic("unreachable") }
    }
}

fn parse_for(mut parser Parser) Expression {
    todo("parse_for")
}

fn parse_while(mut parser Parser) Expression {
    todo("parse_while")
}

fn parse_if(mut parser Parser) Expression {
    todo("parse_if")
}

fn parse_switch(mut parser Parser) Expression {
    todo("parse_switch")
}

fn parse_member_call(mut parser Parser, target Expression, method Ident) Expression {
    todo("parse_member_call")
}

fn parse_call(mut parser Parser, name Ident) Expression {
    let token = parser.mut.expect(lparen)
    mut args = []

    while !parser.has(rparen) {
        let param = parser.peek()
        switch param.kind {
            ident {
                switch parser.peek(2) {
                    colon {
                        let label = parser.mut.expect(ident) else panic("unreachable")
                        parser.mut.expect(colon) else panic("unreachable")
                        let init = switch parser.peek() {
                            comma { label }
                            _ { parser.mut.parse_expression() }
                        }
                        args ++= CallArg(label:, init:)
                    }
                    _ { args ++= CallArg(label: none, init: parser.mut.parse_expression()) }
                }
            }
            _ { args ++= CallArg(label: none, init: parser.mut.parse_expression()) }
        }
        parser.mut.accept(comma)        
    }
    parser.mut.expect(rparen)

    Call(name:, args:, ufcs: false, span: parser.span(token))
}

fn parse_constructor(mut parser Parser) Expression {
    todo("parse_constructor")
}

fn parse_list(mut parser Parser) Expression {
    todo("parse_list")
}

fn parse_group(mut parser Parser) Expression {
    todo("parse_group")
}

fn parse_string_lit(mut parser Parser) String {
    let token = parser.mut.expect(str)
    parser.source.substr(Range(begin: token.span.range.begin + 1, until: token.span.range.until - 1))
}

fn parse_char_lit(mut parser Parser) Rune {
    todo("parse_char_lit")
}

fn parse_num_lit(mut parser Parser) Float {
    todo("parse_num_lit")
}

fn parse_bool_lit(mut parser Parser, value Bool) Expression {
    todo("parse_bool_lit")
}

fn parse_body(mut parser Parser) Block {
    todo("parse_body")
}
