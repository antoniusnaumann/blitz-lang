test "Empty func" {
    let defs = "fn foo() {}".parse()
    var count = 0
    assert defs.len() == 1
    switch defs[0] {
        ast::Fn { count = 1 }
        else { panic("Expected function") }
    }
    assert count == 1
}

test "Type with qualified type field" {
    let defs = "struct Foo { bar wibble::Baz }".parse()
    var count = 0
    assert defs.len() == 1
    switch defs[0] {
        ast::Struct {
        assert it.fields.len() == 1
            let field = it.fields[0]
            assert field.name.name == "bar"
            assert field.type.module.unwrap().name == "wibble"
            assert field.type.name == "Baz"
            count = 1
        }
        else { panic("Expected function") }
    }
    assert count == 1
}

fn parse_file(path String) {
    let content = read(path).unwrap()
    var parser = new_parser(content)
	for parser.tokens |token| {
	    if token.kind == error { print(parser.source.substr(token.span)) }
		assert token.kind != error
	}

	let ast = parser.mut.parse()
}

test "main.blitz" { parse_file("main.blitz") }

test "parser/parser.blitz" { parse_file("parser/parser.blitz") }
test "parser/toplevel.blitz" { parse_file("parser/toplevel.blitz") }
test "parser/expression.blitz" { parse_file("parser/expression.blitz") }
test "parser/lexer.blitz" { parse_file("parser/lexer.blitz") }
test "parser/precedence.blitz" { parse_file("parser/precedence.blitz") }
test "parser/tokens.blitz" { parse_file("parser/tokens.blitz") }
test "parser/parser.test.blitz" { parse_file("parser/parser.test.blitz") }
test "parser/lexer.test.blitz" { parse_file("parser/lexer.test.blitz") }

test "ast/expression.blitz" { parse_file("ast/expression.blitz") }
test "ast/definition.blitz" { parse_file("ast/definition.blitz") }
test "ast/operator.blitz" { parse_file("ast/operator.blitz") }
test "ast/span.blitz" { parse_file("ast/span.blitz") }
test "ast/error.blitz" { parse_file("ast/error.blitz") }

test "std/number.blitz" { parse_file("std/number.blitz") }
test "std/heap.blitz" { parse_file("std/heap.blitz") }
test "std/range.blitz" { parse_file("std/range.blitz") }
test "std/result.blitz" { parse_file("std/result.blitz") }
test "std/bool.blitz" { parse_file("std/bool.blitz") }
test "std/string.blitz" { parse_file("std/string.blitz") }
test "std/list.blitz" { parse_file("std/list.blitz") }
test "std/string.test.blitz" { parse_file("std/string.test.blitz") }

test "hir/expression.blitz" { parse_file("hir/expression.blitz") }
test "hir/definition.blitz" { parse_file("hir/definition.blitz") }
test "hir/scope.blitz" { parse_file("hir/scope.blitz") }

test "resolver/toplevel.blitz" { parse_file("resolver/toplevel.blitz") }
test "resolver/expression.blitz" { parse_file("resolver/expression.blitz") }
test "resolver/resolver.test.blitz" { parse_file("resolver/resolver.test.blitz") }

test "compile.blitz" { parse_file("compile.blitz") }

// test "Should be slow" {
//     var s = "s"
//     var i = 0
//     while i < 100000 {
//         s ++= "s"
//         i += 1
//     }

//     var t = 0
//     for s |e| {
//         for s |m| {
//             t = t + 1
//         }
//     }
// }
