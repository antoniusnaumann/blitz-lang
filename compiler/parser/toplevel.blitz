fn parse_def(mut parser Parser) Option(Definition) {
    let token = parser.peek()
    let result = switch token.kind {
    	struct_ { parser.mut.parse_struct() }
    	union_ { parser.mut.parse_union() }
    	actor_ { parser.mut.parse_actor() }
    	alias_ { parser.mut.parse_alias() }
    	fn_ { parser.mut.parse_fn() }
    	test_ { parser.mut.parse_test() }
    	pub_ {
    	    Pub(item: parser.mut.parse_def.unwrap()) // TODO: generate an error instead of unwrapping
    	}
        else {
            print(token.kind)
            parser.err("Unexpected token for definition!")
            parser.tok()

            none
        }
    }
    parser.mut.skip_newlines()

    result
}

fn parse_struct(mut parser Parser) Option(Struct) {
    let kw = parser.mut.expect(struct_) else return none
    let ty = parser.mut.parse_type() else return none
    let fields = parser.mut.parse_fields() else return none

    Struct(sig: ty, fields:, span: parser.span(kw))
}

fn parse_fields(mut parser Parser) List(Field) {
    parser.mut.expect(lbrace)
    mut fields = []
    while !parser.has(rbrace) {
        let span = parser.span()
        let name = parser.mut.parse_ident() else break
        let type = parser.mut.parse_type() else break
        parser.mut.accept(comma)

        fields ++= Field(name:, type:, span: parser.span(span))
    }
    parser.mut.expect(rbrace) // TODO recover

    fields
}

fn parse_union(mut parser Parser) Option(Union) {
    let kw = parser.mut.expect(union_) else return none
    let ty = parser.mut.parse_type() else return none
    let cases = parser.mut.parse_cases() else return none

    Union(sig: ty, cases:, span: parser.span(kw))
}

fn parse_cases(mut parser Parser) List(Case) {
    parser.mut.expect(lbrace)
    mut cases = []
    while !parser.has(rbrace) {
        let span = parser.span()
        mut label = none
        if parser.has(ident) {
            label = parser.mut.parse_ident()
            if parser.has(colon) {
                parser.mut.tok()
                parser.mut.skip_newlines()
            } else {
                cases ++= Case(label:, type: none)
                continue
            }
        }
        let ty = if parser.has(type) { parser.mut.parse_type() }
        parser.mut.skip_newlines()

        cases ++= Case(label:, type: ty)
    }
    parser.mut.expect(rbrace) // TODO recover

    cases
}

fn parse_actor(mut parser Parser) Option(Actor) {
    let kw = parser.mut.expect(actor_) else return none
    todo("Parse actor")
}

fn parse_alias(mut parser Parser) Option(Alias) {
    let kw = parser.mut.expect(alias_) else return none
    todo("Parse alias")
}

fn parse_fn(mut parser Parser) Option(Fn) {
    let kw = parser.mut.expect(fn_) else return none
    let ident = parser.mut.parse_ident() else return none

    parser.mut.expect(lparen) else return none
    mut args = []
    while parser.mut.accept(rparen) == none {
        let arg = parser.mut.parse_arg() else return none
        args ++= arg
        parser.mut.accept(comma)
    }
    
    let type = if parser.has(type) { parser.mut.parse_type() }
    let body = parser.mut.parse_body()
    
    Fn(name: ident, args:, type:, body:, span: parser.span(kw))
}

fn parse_arg(mut parser Parser) Option(Arg) {
    let span = parser.span()
    let is_mut = parser.mut.accept(mut_) != none
    let ident = parser.mut.parse_ident() else return none
    let type = parser.mut.parse_type() else return none

    Arg(name: ident, type:, is_mut:, span: parser.span(span))
}

fn parse_statement(mut parser Parser) Option(Statement) {
    parser.mut.skip_newlines()
    let token = parser.peek()
    switch token.kind {
        mut_ { parser.mut.parse_declaration() else todo("recover") }
        let_ { parser.mut.parse_declaration() else todo("recover") }
        else { parser.mut.parse_expression() else todo("recover") }
    }
}

fn parse_declaration(mut parser Parser) Option(Declaration) {
    let modifier = parser.tok()
    let is_mut = switch modifier.kind {
        mut_ { false }
        let_ { true }
        else { panic("unreachable") }
    }
    let name = parser.mut.parse_ident() else return none
    let type = if parser.peek().kind != assign { parser.mut.parse_type() else return none }
    parser.mut.expect(assign) else return none
    let init = parser.mut.parse_expression() else return none
    
    Declaration(name:, type:, init:, is_mut:, span: parser.span(modifier))
}

fn parse_ident(mut parser Parser) Option(Ident) {
    let token = parser.mut.expect(ident) else return none
    let name = parser.source.substr(token.span)

    Ident(name:, span: token.span)
}

fn parse_type(mut parser Parser) Option(Type) {
    let token = parser.mut.expect(type) else return none
    let name = parser.source.substr(token.span)
    let params = if parser.has(lparen) { parser.mut.parse_type_params() } else { [] }

    Type(name:, span: token.span, params:)
}

fn parse_type_params(mut parser Parser) List(Type) {
    let token = parser.mut.expect(lparen) else return []

    mut params = []
    while !parser.has(rparen) {
        params ++= parser.mut.parse_type() else return []
        parser.mut.accept(comma)
    }
    parser.mut.expect(rparen)

    params
}

fn parse_test(mut parser Parser) Option(Test) {
    let kw = parser.mut.expect(test_) else return none
    todo("Parse test")
}
