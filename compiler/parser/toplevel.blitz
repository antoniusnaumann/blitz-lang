fn parse_def(mut parser Parser) Option(Definition) {
    let token = parser.peek()
    switch token.kind {
    	struct_ { parser.mut.parse_struct() }
    	union_ { parser.mut.parse_union() }
    	actor_ { parser.mut.parse_actor() }
    	alias_ { parser.mut.parse_alias() }
    	fn_ { parser.mut.parse_fn() }
    	test_ { parser.mut.parse_test() }
    	pub_ {
    	    Pub(item: parser.mut.parse_def.unwrap()) // TODO: generate an error instead of unwrapping
    	}
        _ {
            parser.errors = parser.errors ++ Error(span: token.span, msg: "Unexpected token!")
            parser.tok()

            none
        }
    }
}

fn parse_struct(mut parser Parser) Option(Struct) {
    let kw = parser.mut.expect(struct_) else return none
    todo("Parse struct")
}

fn parse_union(mut parser Parser) Option(Union) {
    let kw = parser.mut.expect(union_) else return none
    todo("Parse union")
}

fn parse_actor(mut parser Parser) Option(Actor) {
    let kw = parser.mut.expect(actor_) else return none
    todo("Parse actor")
}

fn parse_alias(mut parser Parser) Option(Alias) {
    let kw = parser.mut.expect(alias_) else return none
    todo("Parse alias")
}

fn parse_fn(mut parser Parser) Option(Fn) {
    let kw = parser.mut.expect(fn_) else return none
    let ident = parser.mut.parse_ident() else return none

    parser.mut.expect(lparen) else return none
    mut args = []
    while parser.mut.accept(rparen) == none {
        let arg = parser.mut.parse_arg() else return none
        args = args ++ arg
        parser.mut.accept(comma)
    }
    
    let type = parser.mut.accept(type)

    parser.mut.expect(lbrace) else return none

    mut body = []
    while !parser.has(rbrace) {
        print("FUNC BODY")
        let statement = parser.mut.parse_statement() else return none
        body = body ++ statement
        parser.mut.accept(semicolon)
    }

    Fn(name: ident, args:, type:, body:, span: parser.span(kw))
}

fn parse_arg(mut parser Parser) Option(Arg) {
    let span = parser.span()
    let is_mut = parser.mut.accept(mut_) != none
    let ident = parser.mut.parse_ident() else return none
    let type = parser.mut.parse_type() else return none

    Arg(name: ident, type:, is_mut:, span: parser.span(span))
}

fn parse_statement(mut parser Parser) Option(Statement) {
    parser.mut.skip_newlines()
    let token = parser.peek()
    switch token.kind {
        mut_ { parser.mut.parse_declaration() else todo("recover") }
        let_ { parser.mut.parse_declaration() else todo("recover") }
        _ { parser.mut.parse_expression() else todo("recover") }
    }
}

fn parse_declaration(mut parser Parser) Option(Declaration) {
    let modifier = parser.tok()
    let is_mut = switch modifier.kind {
        mut_ { false }
        let_ { true }
        _ { panic("unreachable") }
    }
    let name = parser.mut.parse_ident() else return none
    let type = if parser.peek().kind != assign { parser.mut.parse_type() else return none }
    parser.mut.expect(assign) else return none
    let init = parser.mut.parse_expression() else return none
    
    Declaration(name:, type:, init:, is_mut:, span: parser.span(modifier))
}

fn parse_ident(mut parser Parser) Option(Ident) {
    let token = parser.mut.expect(ident) else return none
    let name = parser.source.substr(token.span)
    Ident(name:, span: token.span)
}

fn parse_type(mut parser Parser) Option(Type) {
    let token = parser.mut.expect(type) else return none
    let name = parser.source.substr(token.span)
    if parser.has(lparen) { todo("Parse generic types") }
    Type(name:, span: token.span)
}

fn parse_test(mut parser Parser) Option(Test) {
    let kw = parser.mut.expect(test_) else return none
    todo("Parse test")
}
