fn parse_def(mut parser Parser) Option(Definition) {
    let token = parser.peek()
    switch token.kind {
    	struct_ { parser.mut.parse_struct() }
    	union_ { parser.mut.parse_union() }
    	actor_ { parser.mut.parse_actor() }
    	alias_ { parser.mut.parse_alias() }
    	fn_ { parser.mut.parse_fn() }
    	test_ { parser.mut.parse_test() }
    	pub_ {
    	    Pub(item: parser.mut.parse_def.unwrap()) // TODO: generate an error instead of unwrapping
    	}
        _ {
            parser.errors = parser.errors ++ Error(span: token.span, msg: "Unexpected token!")
            parser.tok()

            none
        }
    }
}

fn parse_struct(mut parser Parser) Option(Struct) {
    let kw = parser.mut.expect(struct_) else return none
    todo("Parse struct")
}

fn parse_union(mut parser Parser) Option(Union) {
    let kw = parser.mut.expect(union_) else return none
    todo("Parse union")
}

fn parse_actor(mut parser Parser) Option(Actor) {
    let kw = parser.mut.expect(actor_) else return none
    todo("Parse actor")
}

fn parse_alias(mut parser Parser) Option(Alias) {
    let kw = parser.mut.expect(alias_) else return none
    todo("Parse alias")
}

fn parse_fn(mut parser Parser) Option(Fn) {
    let kw = parser.mut.expect(fn_) else return none
    let ident = parser.mut.parse_ident() else return none

    parser.mut.expect(lparen) else return none
    mut args = []
    while parser.mut.accept(rparen) == none {
        let arg = parser.mut.parse_arg() else return none
        args = args ++ arg
        parser.mut.accept(comma)
    }
    
    let type = parser.mut.accept(type)

    parser.mut.expect(lbrace) else return none

    mut body = []
    while !parser.has(rbrace) {
        let statement = parser.mut.parse_statement() else return none
        body = body ++ statement
        parser.mut.accept(semicolon)
    }

    Fn(name: name, args: args, type: type, body: body, span: parser.span(kw))
}

fn parse_arg(mut parser Parser) Option(Arg) {
    let span = parser.span()
    let is_mut = parser.mut.accept(mut_) != none
    let ident = parser.mut.parse_ident() else return none
    let type = parser.mut.parse_type() else return none

    Arg(name: ident, type: type, is_mut: is_mut, span: parser.span(span))
}

fn parse_statement(mut parser Parser) Option(Statement) {
    todo("Parse statement")
}

fn parse_ident(mut parser Parser) Option(Ident) {
    let token = parser.mut.expect(ident) else return none
    let name = parser.source.substr(token.span)
    Ident(name: name, span: token.span)
}

fn parse_type(mut parser Parser) Option(Type) {
    let token = parser.mut.expect(type) else return none
    let name = parser.source.substr(token.span)
    if parser.has(lparen) { todo("Parse generic types") }
    Type(name: name, span: token.span)
}

fn parse_test(mut parser Parser) Option(Test) {
    let kw = parser.mut.expect(test_) else return none
    todo("Parse test")
}
