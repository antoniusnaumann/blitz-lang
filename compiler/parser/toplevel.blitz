fn parse_def(mut parser Parser) Option(ast::Definition) {
    let token = parser.peek()
    let result = switch token.kind {
    	struct_ { parser.mut.parse_struct() }
    	union_ { parser.mut.parse_union() }
    	actor_ { parser.mut.parse_actor() }
    	alias_ { parser.mut.parse_alias() }
    	fn_ { parser.mut.parse_fn() }
    	test_ { parser.mut.parse_test() }
    	pub_ {
    	    ast::Pub(item: parser.mut.parse_def.unwrap()) // TODO: generate an error instead of unwrapping
    	}
        else {
            print(token.kind)
            parser.err("Unexpected token for definition!")
            parser.tok()

            none
        }
    }
    parser.mut.skip_newlines()

    result
}

fn parse_struct(mut parser Parser) Option(ast::Struct) {
    let kw = try parser.mut.expect(struct_)
    let ty = try parser.mut.parse_type()
    let fields = try parser.mut.parse_fields()

    ast::Struct(sig: ty, fields:, span: parser.span(kw))
}

fn parse_fields(mut parser Parser) List(ast::Field) {
    parser.mut.expect(lbrace)
    var fields = []

    parser.mut.skip_newlines()
    while !parser.has(rbrace) {
        let span = parser.span()
        let name = parser.mut.parse_ident() else break
        let type = parser.mut.parse_qualified_type() else break
        parser.mut.accept(comma)

        fields ++= ast::Field(name:, type:, span: parser.span(span))
    }
    parser.mut.expect(rbrace) // TODO recover

    fields
}

fn parse_union(mut parser Parser) Option(ast::Union) {
    let kw = try parser.mut.expect(union_)
    let ty = try parser.mut.parse_type()
    let cases = try parser.mut.parse_cases()

    ast::Union(sig: ty, cases:, span: parser.span(kw))
}

fn parse_cases(mut parser Parser) List(ast::Case) {
    parser.mut.expect(lbrace)
    var cases = []
    parser.mut.skip_newlines()
    while !parser.has(rbrace) {
        let span = parser.span()
        var label = none
        if parser.has(ident) {
            label = parser.mut.parse_ident()
            if parser.has(colon) {
                parser.mut.tok()
                parser.mut.skip_newlines()
            } else {
                cases ++= ast::Case(label:, type: none)
                continue
            }
        }
        let ty = if parser.has([type, ident]) { parser.mut.parse_qualified_type() }
        parser.mut.skip_newlines()

        cases ++= ast::Case(label:, type: ty)
    }
    parser.mut.expect(rbrace) // TODO recover

    cases
}

fn parse_actor(mut parser Parser) Option(ast::Actor) {
    let kw = try parser.mut.expect(actor_)
    todo("Parse actor")
}

fn parse_alias(mut parser Parser) Option(ast::Alias) {
    let kw = try parser.mut.expect(alias_)
    todo("Parse alias")
}

fn parse_fn(mut parser Parser) Option(ast::Fn) {
    let kw = try parser.mut.expect(fn_)
    let ident_ = try parser.mut.parse_ident()

    try parser.mut.expect(lparen)
    var args = []
    while parser.mut.accept(rparen) == none {
        let arg = try parser.mut.parse_arg()
        args ++= arg
        parser.mut.accept(comma)
    }
    
    let type = if parser.has([type, ident]) { parser.mut.parse_qualified_type() }
    let body = parser.mut.parse_body()
    
    ast::Fn(name: ident_, args:, type:, body:, span: parser.span(kw))
}

fn parse_arg(mut parser Parser) Option(ast::Arg) {
    let span = parser.span()
    let is_mut = parser.mut.accept(mut_) != none
    let ident = try parser.mut.parse_ident()
    let type = try parser.mut.parse_qualified_type()

    ast::Arg(name: ident, type:, is_mut:, span: parser.span(span))
}

fn parse_statement(mut parser Parser) Option(ast::Statement) {
    parser.mut.skip_newlines()
    let token = parser.peek()
    switch token.kind {
        var_ { parser.mut.parse_declaration() else todo("recover") }
        let_ { parser.mut.parse_declaration() else todo("recover") }
        else { parser.mut.parse_expression() else todo("recover") }
    }
}

fn parse_declaration(mut parser Parser) Option(ast::Declaration) {
    let modifier = parser.tok()
    let is_mut = switch modifier.kind {
        var_ { true }
        let_ { false }
        else { panic("unreachable") }
    }
    let name = try parser.mut.parse_ident()
    let type = if parser.peek().kind != assign { try parser.mut.parse_qualified_type() }
    try parser.mut.expect(assign)
    let init = try parser.mut.parse_expression()
    
    ast::Declaration(name:, type:, init:, is_mut:, span: parser.span(modifier))
}

fn parse_ident(mut parser Parser) Option(ast::Ident) {
    let token = try parser.mut.expect(ident)
    let name = parser.source.substr(token.span)

    ast::Ident(name:, span: token.span)
}

fn parse_qualified_type(mut parser Parser) Option(ast::Type) {
    let mod = if parser.has(ident) {
        let ident = parser.mut.parse_ident().unwrap()
        try parser.mut.expect(path) // TODO: Better error reporting here, i.e., reporting that a lower case type was encountered where upper case was expected
        ident
    }
    var ty = parser.mut.parse_type()
    ty.module = mod

    ty
}

fn parse_type(mut parser Parser) Option(ast::Type) {
    let token = try parser.mut.expect(type)
    let name = parser.source.substr(token.span)
    let params = if parser.has(lparen) { parser.mut.parse_type_params() } else { [] }

    ast::Type(name:, span: token.span, params:, module: none)
}

fn parse_type_ident(mut parser Parser) Option(ast::Type) {
    let token = try parser.mut.expect(type)
    let name = parser.source.substr(token.span)

    ast::Type(name:, span: token.span, params: [], module: none)
}

fn parse_type_params(mut parser Parser) List(ast::Type) {
    let token = parser.mut.expect(lparen) else return []

    var params = []
    while !parser.has(rparen) {
        params ++= parser.mut.parse_qualified_type() else return []
        parser.mut.accept(comma)
    }
    parser.mut.expect(rparen)

    params
}

fn parse_test(mut parser Parser) Option(ast::Test) {
    let kw = try parser.mut.expect(test_)
    let token = try parser.mut.expect(str)
    let name = parser.source.substr(token.span.range.begin + 1, token.span.range.until - 1)
    let body = try parser.mut.parse_body()

    ast::Test(name:, body:, span: parser.span(kw))
}
