struct ModuleStub {
    asts List(ast::Ast)
    path String
    name String
}

fn lower(asts List(ast::Ast)) hir::Hir {
    var stubs = []
    for asts |ast| {
        stubs.mut.insert(ast)        
    }

    var hir = hir::new_hir()
    var index = hir.mods.len()

    for stubs |stub| {
        let mod = new_module(stub.name, hir::ModId(id: index))

        for stub.asts |ast| {
            for ast.items |item| {
                mod.mut.push_sig(mut hir.types, item)
            }
        }

        hir.mut.push(mod)
        index += 1
    }

    index = hir.mods.len() - stubs.len()

    for stubs |stub| {
        let mod_id = hir::ModId(id: index)
        for stub.asts |ast| {
            for ast.items |item| {
                item.lower_into(mut hir, mod_id)
            }
        }
        
        index += 1 
    }

    hir
}

fn insert(mut stubs List(ModuleStub), ast ast::Ast) {
    var index = 0 
    while index < stubs.len() {
        if stubs[index].path == ast.origin.mod_path() {
            stubs[index].asts ++= ast
            return
        }
        index += 1
    }

    stubs ++= ModuleStub(asts: [ast], path: ast.origin.mod_path(), name: ast.origin.mod_name())
}

fn mod_name(path String) String {
    let split = path.split('/')
    if split.len() < 2 { "" }

    split[split.len() - 2]
}

fn mod_path(path String) String {
    let split = path.split('/')
    var result = ""
    var index = 0
    while index < split.len() - 1 {
        result ++= split[index]
        result ++= '/'
        index += 1
    }

    result
}

fn push_sig(mut mod hir::Module, mut types List(hir::TypeKind), item ast::Definition) {
    switch item {
        ast::Pub { todo("HIR: pub") }
        ast::Struct { mod.mut.push(item.sig(mut types)) }
        ast::Union { mod.mut.push(item.sig(mut types)) }
        ast::Alias { mod.mut.push(item.sig(mut types)) }
        ast::Actor { mod.mut.push(item.sig(mut types)) }
        ast::Fn { mod.mut.push(item.sig(mut types)) }
        ast::Test { mod.mut.push(item.sig(mut types)) }
    }
}

fn sig(def ast::Struct, mut types List(hir::TypeKind)) hir::TypeDef {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)

    // TODO: type parameters
    hir::TypeDef(name:, generic: [], kind: hir::StructDef(fields: []), vis: module)
}

fn sig(def ast::Union, mut types List(hir::TypeKind)) hir::TypeDef {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)

    // TODO: type parameters
    hir::TypeDef(name:, generic: [], kind: hir::UnionDef(cases: []), vis: module)
}

fn sig(def ast::Fn, mut types List(hir::TypeKind)) hir::FuncDef {
    hir::FuncDef(name: def.name, generic: [], params: [], result: hir::TypeRef(id: 0), body: hir::Body(expressions: []), vis: module)
}

fn sig(def ast::Alias, mut types List(hir::TypeKind)) hir::TypeDef {
    todo("HIR: alias")
}

fn sig(def ast::Actor, mut types List(hir::TypeKind)) hir::TypeDef {
    todo("HIR: actor")
}

fn sig(def ast::Test, mut types List(hir::TypeKind)) hir::FuncDef {
    todo("HIR: test")
}

fn lower_into(item ast::Definition, mut hir hir::Hir, mod_id hir::ModId) {
    switch item {
        ast::Pub { todo("HIR: pub") }
        ast::Struct { it.lower_into(mut hir, mod_id) }
        ast::Union { it.lower_into(mut hir, mod_id) }
        ast::Alias { todo("HIR: alias") }
        ast::Actor { todo("HIR: actor") }
        ast::Fn { it.lower_into(mut hir, mod_id) }
        ast::Test { todo("HIR: test") }
    }
}

fn resolve_type(hir hir::Hir, mod_id hir::ModId, ty ast::Type, mut types List(hir::TypeKind)) hir::TypeRef {
    let chars = ty.name.chars()
    let result = if ty.params.len() == 0 and chars.len() == 1 {
        hir::GenericId(letter: chars[0])
    } else {
        let args = for ty.params |param| {
            resolve_type(hir, mod_id, param, mut types)
        }

        // Resolve type: check qualified module, then current module, then core
        let def_id = if ty.module != none {
            let mod_name = ty.module.unwrap().name
            let target_mod = hir.find(mod_name)
            if target_mod != none {
                hir.find_type(target_mod.unwrap(), ty.name)
            } else {
                none
            }
        } else {
            // Try current module first, then core
            let in_mod = hir.find_type(mod_id, ty.name)
            if in_mod != none { in_mod }
            else { hir.find_type(hir::ModId(id: 0), ty.name) }
        }

        hir::Nominal(def_id: def_id else { hir::TypeId(module: mod_id, id: 0) }, args:)
    }
    types.mut.insert(result)    
}

fn lower_into(def ast::Struct, mut hir hir::Hir, mod_id hir::ModId) {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)
    var fields = []
    for def.fields |field| {
        let field_type = resolve_type(hir, mod_id, field.type, mut hir.types)
        fields ++= hir::FieldDef(name: field.name, type: field_type)
    }

    // Find the existing stub and update it
    let id = hir.mods[mod_id.id].find_type(def.sig.name).unwrap().id
    // TODO: type parameters
    hir.mods[mod_id.id].mut.set_type(id, hir::TypeDef(name:, generic: [], kind: hir::StructDef(fields:), vis: module))
    
}

fn lower_into(def ast::Union, mut hir hir::Hir, mod_id hir::ModId) {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)
    let kind = hir::UnionDef(cases: [])

    // Find the existing stub and update it
    let id = hir.mods[mod_id.id].find_type(def.sig.name).unwrap().id
    // TODO: type parameters
    hir.mods[mod_id.id].mut.set_type(id, hir::TypeDef(name:, generic: [], kind:, vis: module))
}

fn lower_into(def ast::Fn, mut hir hir::Hir, mod_id hir::ModId) {
    let name = def.name
    var params = []
    for def.args |arg| {
        let param_type = resolve_type(hir, mod_id, arg.type, mut hir.types)
        params ++= param_type
    }

    let result = if def.type != none {
        resolve_type(hir, mod_id, def.type.unwrap(), mut hir.types)
    } else {
        hir::void_type()
    }

    // Find the existing function stub and update it
    let id = hir.mods[mod_id.id].find_func(name.name).unwrap().id
    // TODO: type parameters
    // TODO: lower expressions
    hir.mods[mod_id.id].mut.set_func(id, hir::FuncDef(name:, generic: [], params:, result:, body: hir::Body(expressions: []), vis: module))
}
