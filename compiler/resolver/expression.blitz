// Expression lowering: AST expressions → HIR expression arena
//
// The primary entry point is `lower_body`, which lowers an `ast::Block` into
// a `hir::Body` (an expression arena).  Internally every node is flattened
// into the arena via `lower_expr` / `lower_stmt` and referenced by an
// `ExpressionId`.
//
// Name resolution strategy
// ─────────────────────────
// • Local variables are resolved through a `ScopeArena` that tracks bindings.
// • Function calls produce a *candidate list* of `FuncId`s found by name
//   across accessible modules. The type checker will narrow the list to a single overload.
// • Constructors resolve the type name to a `TypeId` when possible; if the
//   type is not found a placeholder id is used and a diagnostic is emitted.
// • `else` operator (binary): lowered as a BinaryOp so the type checker can
//   later understand it as "unwrap or short-circuit".

// ── Resolver context ────────────────────────────────────────────────────────

struct ResolverCtx {
	hir    hir::Hir
	mod_id hir::ModId
	errors List(ast::Error)
}

fn new_ctx(hir hir::Hir, mod_id hir::ModId) ResolverCtx {
	ResolverCtx(hir:, mod_id:, errors: [])
}

// TODO LLM: rename this into err, to be consistent with the parser
fn emit(mut ctx ResolverCtx, msg String, span ast::Span) {
	ctx.errors ++= ast::Error(span:, msg:)
}

// ── Candidate resolution ─────────────────────────────────────────────────────

// Collect all FuncDef IDs whose name matches `name` that are visible from
// the current module.  Searches: qualified module (if given) → current module
// → core module → all other modules (for UFCS whose receiver type determines
// the module).
// TODO: the 'all other modules' rule will be removed in the future and std will be imported implicitly
fn find_candidates(ctx ResolverCtx, name String, module Option(ast::Ident)) List(hir::FuncId) {
	var candidates = []

	if module != none {
		// Qualified call: module::func(...)
		let mod_name = module.unwrap().name
		let target = ctx.hir.find(mod_name)
		if target != none {
			collect_func_candidates(ctx.hir, target.unwrap(), name, mut candidates)
		}
		return candidates
	}

	// Current module
	collect_func_candidates(ctx.hir, ctx.mod_id, name, mut candidates)

	// Core module (id 0), unless current module is core
	// TODO LLM: use the hir helper function that has the core ID instead of hardcoding this
	if ctx.mod_id.id != 0 {
		collect_func_candidates(ctx.hir, hir::ModId(id: 0), name, mut candidates)
	}

	// All other modules (to handle UFCS where receiver's module is unknown
	// until the type checker resolves the receiver type)
	// TODO: this will be more fine-grained in the future and only point to std
	var i = 1
	while i < ctx.hir.mods.len() {
		if i != ctx.mod_id.id {
			collect_func_candidates(ctx.hir, hir::ModId(id: i), name, mut candidates)
		}
		i += 1
	}

	candidates
}


fn collect_func_candidates(hir hir::Hir, mod_id hir::ModId, name String, mut out List(hir::FuncId)) {
	let mod = hir.get(mod_id)
	var i = 0
	while i < mod.funcs.len() {
		if mod.funcs[i].name.name == name {
			out ++= hir::FuncId(module: mod_id, id: i)
		}
		i += 1
	}
}

// Resolve a type name to a TypeId.  Returns `none` and emits a diagnostic if
// the type cannot be found.
fn resolve_type_id(mut ctx ResolverCtx, ty ast::Type) Option(hir::TypeId) {
	if ty.module != none {
		let mod_name = ty.module.unwrap().name
		let target = ctx.hir.find(mod_name)
		if target == none {
			ctx.mut.emit("Unknown module '" ++ mod_name ++ "'", ty.span)
			return none
		}
		let found = ctx.hir.find_type(target.unwrap(), ty.name)
		if found == none {
			ctx.mut.emit("Unknown type '" ++ ty.name ++ "' in module '" ++ mod_name ++ "'", ty.span)
			return none
		}
		return found.unwrap()
	}

	// Try current module first, then core
	let in_mod = ctx.hir.find_type(ctx.mod_id, ty.name)
	if in_mod != none { return in_mod.unwrap() }

	let in_core = ctx.hir.find_type(hir::ModId(id: 0), ty.name)
	if in_core == none {
		ctx.mut.emit("Unknown type '" ++ ty.name ++ "'", ty.span)
	}
	in_core
}

// ── Body lowering ─────────────────────────────────────────────────────────────

// Lower an ast::Block into a hir::Body. Populates a fresh ScopeArena for
// the function body.  For functions with parameters, use lower_body_with_params.
fn lower_body(block ast::Block, hir hir::Hir, mod_id hir::ModId) hir::Body {
	var body = hir::Body(expressions: [])
	var arena = hir::new_scope_arena()
	let root_scope = arena.mut.push_root()
	var ctx = new_ctx(hir, mod_id)

	lower_block(block, mut body, mut arena, root_scope, mut ctx)

	body
}

// Lower an ast::Block that also takes parameters as pre-declared bindings.
// TODO LLM: rename to just lower_body and rely on overload resolution
fn lower_body_with_params(block ast::Block, params List(ast::Arg), hir hir::Hir, mod_id hir::ModId) hir::Body {
	var body = hir::Body(expressions: [])
	var arena = hir::new_scope_arena()
	let root_scope = arena.mut.push_root()
	var ctx = new_ctx(hir, mod_id)

	for params |param| {
		arena.mut.define(root_scope, param.name, param.is_mut)
	}

	lower_block(block, mut body, mut arena, root_scope, mut ctx)

	body
}

// ── Block lowering ────────────────────────────────────────────────────────────

// Lower the statements of `block` into the arena, in a fresh child scope.
// Returns the ExpressionId of a Block node that lists the statement IDs.
fn lower_block(block ast::Block, mut body hir::Body, mut arena hir::ScopeArena, parent_scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let scope = arena.mut.push_child(parent_scope)
	var stmt_ids = []

	for block.statements |stmt| {
		stmt_ids ++= lower_stmt(stmt, mut body, mut arena, scope, mut ctx)
	}

	body.mut.push(hir::Expression(kind: hir::Block(stmts: stmt_ids), span: block.span))
}

// ── Statement lowering ────────────────────────────────────────────────────────

fn lower_stmt(stmt ast::Statement, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	switch stmt {
		ast::Declaration { lower_decl(it, mut body, mut arena, scope, mut ctx) }
		ast::Expression  { lower_expr(it, mut body, mut arena, scope, mut ctx) }
	}
}

// Resolve the optional explicit type annotation in a declaration.
// Returns none if no annotation is present or if the type cannot be resolved.
fn resolve_decl_type(decl ast::Declaration, mut ctx ResolverCtx) Option(hir::TypeRef) {
	if decl.type == none {
		return none
	}
	let ty = decl.type.unwrap()
	let type_id = ctx.mut.resolve_type_id(ty)
	if type_id == none {
		return none
	}
	hir::TypeRef(id: type_id.unwrap().id)
}

fn lower_decl(decl ast::Declaration, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let init_id = lower_expr(decl.init, mut body, mut arena, scope, mut ctx)
	let type_ref_opt = resolve_decl_type(decl, mut ctx)
	let binding_id = arena.mut.define(scope, decl.name, decl.is_mut)

	body.mut.push(hir::Expression(
		kind: hir::Let(name: decl.name, type_: type_ref_opt, init: init_id, is_mut: decl.is_mut, binding_id:),
		span: decl.span
	))
}

// ── Expression lowering ───────────────────────────────────────────────────────

fn lower_expr(expr ast::Expression, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	switch expr {
		ast::Literal    { lower_literal(it, mut body) }
		ast::Ident      { lower_ident(it, mut body, arena, scope, mut ctx) }
		ast::Call       { lower_call(it, mut body, mut arena, scope, mut ctx) }
		ast::Constructor { lower_constructor(it, mut body, mut arena, scope, mut ctx) }
		ast::Member     { lower_member(it, mut body, mut arena, scope, mut ctx) }
		ast::BinaryOp   { lower_binary_op(it, mut body, mut arena, scope, mut ctx) }
		ast::UnaryOp    { lower_unary_op(it, mut body, mut arena, scope, mut ctx) }
		ast::Assignment { lower_assignment(it, mut body, mut arena, scope, mut ctx) }
		ast::If         { lower_if(it, mut body, mut arena, scope, mut ctx) }
		ast::While      { lower_while(it, mut body, mut arena, scope, mut ctx) }
		ast::For        { lower_for(it, mut body, mut arena, scope, mut ctx) }
		ast::Switch     { lower_switch(it, mut body, mut arena, scope, mut ctx) }
		ast::Block      { lower_block(it, mut body, mut arena, scope, mut ctx) }
		ast::Return     { lower_return(it, mut body, mut arena, scope, mut ctx) }
		ast::Break      { body.mut.push(hir::Expression(kind: hir::Break(), span: it.span)) }
		ast::Continue   { body.mut.push(hir::Expression(kind: hir::Continue(), span: it.span)) }
		ast::Assert     { lower_assert(it, mut body, mut arena, scope, mut ctx) }
		ast::Mut        { lower_mut(it, mut body, mut arena, scope, mut ctx) }
		ast::Try        { lower_try(it, mut body, mut arena, scope, mut ctx) }
		ast::List_      { lower_list(it, mut body, mut arena, scope, mut ctx) }
		ast::Index      { lower_index(it, mut body, mut arena, scope, mut ctx) }
		ast::Group      { lower_group(it, mut body, mut arena, scope, mut ctx) }
	}
}

// ── Literals ──────────────────────────────────────────────────────────────────

fn lower_literal(lit ast::Literal, mut body hir::Body) hir::ExpressionId {
	switch lit {
		ast::Lit(Int)    { body.mut.push(hir::Expression(kind: hir::LitInt(value: it.value), span: it.span)) }
		ast::Lit(Float)  { body.mut.push(hir::Expression(kind: hir::LitFloat(value: it.value), span: it.span)) }
		ast::Lit(String) { body.mut.push(hir::Expression(kind: hir::LitString(value: it.value), span: it.span)) }
		ast::Lit(Rune)   { body.mut.push(hir::Expression(kind: hir::LitRune(value: it.value), span: it.span)) }
	}
}

// ── Identifier ───────────────────────────────────────────────────────────────
// An `ast::Ident` is either a local variable reference or a bare union-case
// label (e.g. `none`, `true`, `false`, or a label-only case like `public`).
// In the HIR we emit `LocalRef` for known bindings and a zero-argument `Call`
// with candidates for everything else (the type checker will resolve it).

fn lower_ident(ident ast::Ident, mut body hir::Body, arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let binding = arena.lookup(scope, ident.name)
	if binding != none {
		return body.mut.push(hir::Expression(kind: hir::LocalRef(name: ident, binding_id: binding.unwrap().binding_id), span: ident.span))
	}

	// Not a local — treat as a zero-argument call so candidate resolution
	// can find the right enum case or nullary function.
	let candidates = ctx.find_candidates(ident.name, none)
	body.mut.push(hir::Expression(kind: hir::Call(name: ident, module: none, candidates:, args: []), span: ident.span))
}

// ── Calls ─────────────────────────────────────────────────────────────────────

fn lower_call(call ast::Call, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let candidates = ctx.find_candidates(call.name.name, call.module)
	var args = []
	for call.args |arg| {
		let value = lower_expr(arg.init, mut body, mut arena, scope, mut ctx)
		args ++= hir::Argument(label: arg.label, value:)
	}
	body.mut.push(hir::Expression(kind: hir::Call(name: call.name, module: call.module, candidates:, args:), span: call.span))
}

// ── Constructors ──────────────────────────────────────────────────────────────
// TODO LLM: you abbreviated to aggressively here and in a few cases below, prefer readable names such as constructor or member. common abbreviations like ctx and op are okay
fn lower_constructor(ctor ast::Constructor, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	// Resolve the type name to a TypeId (best-effort; unknown types get id 0)
	let type_id = ctx.mut.resolve_type_id(ctor.type)
	let resolved_id = if type_id != none {
		type_id.unwrap()
	} else {
		hir::TypeId(module: ctx.mod_id, id: 0)
	}

	var args = []
	for ctor.args |arg| {
		let value = lower_expr(arg.init, mut body, mut arena, scope, mut ctx)
		args ++= hir::FieldInit(label: arg.label, value:)
	}

	body.mut.push(hir::Expression(
		kind: hir::Constructor(type_id: resolved_id, type_name: ast::Ident(name: ctor.type.name, span: ctor.type.span), args:),
		span: ctor.span
	))
}

// ── Member access ─────────────────────────────────────────────────────────────

fn lower_member(mem ast::Member, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let expr_id = lower_expr(mem.parent, mut body, mut arena, scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::Member(expr: expr_id, field: mem.member), span: mem.span))
}

// ── Binary / unary operations ─────────────────────────────────────────────────

fn lower_binary_op(op ast::BinaryOp, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let left_id  = lower_expr(op.left, mut body, mut arena, scope, mut ctx)
	let right_id = lower_expr(op.right, mut body, mut arena, scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::BinaryOp(op: op.op, left: left_id, right: right_id), span: op.span))
}

fn lower_unary_op(op ast::UnaryOp, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let expr_id = lower_expr(op.expr, mut body, mut arena, scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::UnaryOp(op: op.op, expr: expr_id), span: op.span))
}

// ── Assignment ────────────────────────────────────────────────────────────────

fn lower_assignment(assign ast::Assignment, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let target_id = lower_expr(assign.left, mut body, mut arena, scope, mut ctx)
	let value_id  = lower_expr(assign.right, mut body, mut arena, scope, mut ctx)
	// TODO: ast::Assignment has no span field (unlike other expression structs).
	// Add `span Span` to Assignment and populate it in the parser.
	body.mut.push(hir::Expression(kind: hir::Assign(target: target_id, value: value_id), span: ast::empty_span()))
}

// ── Control flow ──────────────────────────────────────────────────────────────

fn lower_if(if_ ast::If, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let cond_id = lower_expr(if_.cond, mut body, mut arena, scope, mut ctx)
	let then_id = lower_block(if_.body, mut body, mut arena, scope, mut ctx)
	// TODO LLM: regarding the TODO below, it is quite okay to do this similar to the AST, i.e., binary operator style in the HIR, so the hir::If struct should have no else body but instead be a left-hand side of the else operator when part of an if-else
	// TODO: lower if-else properly.  The parser represents `if c { a } else { b }` as
	// BinaryOp(op: else_, left: If(...), right: Block(...)), so `else_body` is always
	// none here.  Detect the else_ binary-op pattern in lower_binary_op and produce a
	// proper hir::If with else_body populated.
	body.mut.push(hir::Expression(kind: hir::If(cond: cond_id, then_body: then_id, else_body: none), span: if_.span))
}

fn lower_while(while_ ast::While, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let cond_id = lower_expr(while_.cond, mut body, mut arena, scope, mut ctx)
	let body_id = lower_block(while_.body, mut body, mut arena, scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::While(cond: cond_id, body: body_id), span: while_.span))
}

fn lower_for(for_ ast::For, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let iter_id = lower_expr(for_.iter, mut body, mut arena, scope, mut ctx)

	// The loop binding is visible inside the body only.
	let inner_scope = arena.mut.push_child(scope)
	arena.mut.define(inner_scope, for_.elem, false)

	let body_id = lower_block(for_.body, mut body, mut arena, inner_scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::For(iter: iter_id, binding: for_.elem, body: body_id), span: for_.span))
}

fn lower_switch(sw ast::Switch, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let cond_id = lower_expr(sw.cond, mut body, mut arena, scope, mut ctx)

	var hir_cases = []
	for sw.cases |case| {
		let label = lower_switch_label(case.label, mut ctx)
		let case_body = lower_block(case.body, mut body, mut arena, scope, mut ctx)
		hir_cases ++= hir::SwitchCase(label:, body: case_body, span: case.span)
	}

	body.mut.push(hir::Expression(kind: hir::Switch(cond: cond_id, cases: hir_cases), span: sw.span))
}

fn lower_switch_label(label ast::SwitchLabel, mut ctx ResolverCtx) hir::SwitchLabel {
	switch label {
		ast::Type {
			let type_id = ctx.mut.resolve_type_id(it)
			let resolved = if type_id != none {
				type_id.unwrap()
			} else {
				hir::TypeId(module: ctx.mod_id, id: 0)
			}
			hir::TypeCase(type_id: resolved, type_name: ast::Ident(name: it.name, span: it.span))
		}
		ast::Ident {
			hir::IdentCase(name: it)
		}
		ast::Literal {
			// TODO LLM: don't use a hack here, pass a body here so that this can be solved
			// We can't push into the body here without a body reference, so we
			// encode literal switch labels as IdentCase carrying the source text.
			// The type checker will recognise them as literals.
			todo("Literal switch label lowering requires body access — encode as IdentCase for now")
		}
		default { defaultCase }
	}
}

// ── Return ────────────────────────────────────────────────────────────────────

fn lower_return(ret ast::Return, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	switch ret.expr {
		ast::Block {
			// The parser encodes "empty return" as `Return(expr: Block(statements: [], ...))`.
			// Detect that case and emit `Return(expr: none)`.
			if it.statements.len() == 0 {
				return body.mut.push(hir::Expression(kind: hir::Return(expr: none), span: ret.span))
			}
			let expr_id = lower_block(it, mut body, mut arena, scope, mut ctx)
			body.mut.push(hir::Expression(kind: hir::Return(expr: expr_id), span: ret.span))
		}
		else {
			let expr_id = lower_expr(ret.expr, mut body, mut arena, scope, mut ctx)
			body.mut.push(hir::Expression(kind: hir::Return(expr: expr_id), span: ret.span))
		}
	}
}

// ── Special operators ─────────────────────────────────────────────────────────

fn lower_assert(a ast::Assert, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let cond_id = lower_expr(a.cond, mut body, mut arena, scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::Assert(cond: cond_id), span: a.span))
}

fn lower_mut(m ast::Mut, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let expr_id = lower_expr(m.expr, mut body, mut arena, scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::Mut(expr: expr_id), span: m.span))
}

fn lower_try(t ast::Try, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let expr_id = lower_expr(t.expr, mut body, mut arena, scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::Try(expr: expr_id), span: t.span))
}

fn lower_list(list ast::List_, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	var elem_ids = []
	for list.elems |elem| {
		elem_ids ++= lower_expr(elem, mut body, mut arena, scope, mut ctx)
	}
	body.mut.push(hir::Expression(kind: hir::ListLit(elems: elem_ids), span: list.span))
}

fn lower_index(idx ast::Index, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let target_id = lower_expr(idx.target, mut body, mut arena, scope, mut ctx)
	let index_id  = lower_expr(idx.index, mut body, mut arena, scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::Index(target: target_id, index: index_id), span: idx.span))
}

fn lower_group(g ast::Group, mut body hir::Body, mut arena hir::ScopeArena, scope hir::ScopeId, mut ctx ResolverCtx) hir::ExpressionId {
	let expr_id = lower_expr(g.expr, mut body, mut arena, scope, mut ctx)
	body.mut.push(hir::Expression(kind: hir::Group(expr: expr_id), span: g.span))
}
