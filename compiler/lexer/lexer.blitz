struct Lexer {
	// TODO: this should become an iterator or be byte indexed string that remembers char position instead of a list of chars
	source List(Char)
	errors List(Error)
	index  Int
}

fn new_lexer(source String) Lexer {
	Lexer(source: source.chars(), errors: [], index: 0)
}

fn next(mut lexer Lexer) Option(Token) {
	lexer.mut.skip_space()
	if lexer.source.len() <= lexer.index {
		none
	} else {
		let start = lexer.index
		let ch = lexer.curr()
		lexer.mut.advance()

		let kind = switch ch {
			'+' {
				switch lexer.curr() {
					'+' { lexer.mut.up(concat) }
					_ { add }
				}
			}
			'-' { sub }
			'*' { mul }
			'/' {
				switch lexer.curr() {
					'/' { panic("Comments not implemented yet") }
					_ { div }
				}
			}
			'%' { rem }
			'=' {
				switch lexer.curr() {
					'=' { lexer.mut.up(eq) }
					_  { assign }
				}
			}
			'<' {
				switch lexer.curr() {
					'=' { lexer.mut.up(le) }
					_ { lt }
				}
			}
			'>' {
				switch lexer.curr() {
					'=' { lexer.mut.up(ge) }
					_ { gt }
				}
			}
			'!' {
				switch lexer.curr() {
					'=' { lexer.mut.up(ne) }
					_ { not }
				}
			}
			'(' { lparen }
			')' { rparen }
			'[' { lbracket }
			']' { rbracket }
			'{' { lbrace }
			'}' { rbrace }
			',' { comma }
			'.' { dot }
			':' { colon }
			';' { semicolon }
			'|' { pipe }
			'\n' { newline }
			'\0' { none }
			'"' {
				lexer.mut.skip_str()
					lexer.substr(start, lexer.index).print()
				str
			}
			'\'' {
				lexer.mut.skip_ch()
					lexer.substr(start, lexer.index).print()
				ch
			}
			_ {
				if ch >= 'a' and ch <= 'z' {
					lexer.mut.skip_ident()
					// TODO: remove
					lexer.substr(start, lexer.index).print()
					ident
				} else if ch >= 'A' and ch <= 'Z' {
					lexer.mut.skip_ident()
					// TODO: remove
					lexer.substr(start, lexer.index).print()
					type
				} else { error }
			}
		}

		let span = Span(range: Range(begin: start, until: lexer.index))
		Token(kind: kind, span: span)
	}
}

fn up(mut lexer Lexer, kind TokenKind) TokenKind {
	lexer.mut.advance()
	kind
}

fn advance(mut lexer Lexer) {
	lexer.index = lexer.index + 1
}

fn curr(mut lexer Lexer) Char {
	if lexer.index < lexer.source.len() {
		lexer.source[lexer.index]
	} else {
		'\0'
	}
}

fn peek(lexer Lexer) Char {
	lexer.source[lexer.index + 1]
}

fn peek(lexer Lexer, n Int) Char {
	lexer.source[lexer.index + n]
}

fn substr(lexer Lexer, start Int, until Int) String {
	let str = ""
	mut index = start
	while index < until {
		str = str ++ lexer.source[index]
		index = index + 1
	}

	str
}

fn is_ident_char(lexer Lexer) Bool {
	let ch = lexer.curr()
	(ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or (ch >= '0' and ch <= '9') or ch == '_'
}

fn skip_space(mut lexer Lexer) {
	while lexer.curr() == ' ' or lexer.curr() == '\t' {
		lexer.mut.advance()
	}
}

fn skip_ident(mut lexer Lexer) {
	while lexer.is_ident_char() {
		lexer.mut.advance()
	}
}

fn skip_str(mut lexer Lexer) {
	mut escape = false
	while true {
		if escape {
			switch lexer.curr() {
				'(' { todo("Implement format strings") }
				_ { } // escape sequences are generally handled in parser
			}
			escape = false
		} else {
			switch lexer.curr() {
				'"' {
					lexer.mut.advance()
					return
				}
				'\\' { escape = true }
				'\0' { return }
				_ { }
			}
		}
		lexer.mut.advance()
	}
}

fn skip_ch(mut lexer Lexer) {
	mut escape = false
	while true {
		if escape {
			escape = false
		} else {
			switch lexer.curr() {
				'\'' {
					lexer.mut.advance()
					return
				}
				'\\' { escape = true }
				'\0' { return }
				_ { }
			}
		}
		lexer.mut.advance()
	}
}

