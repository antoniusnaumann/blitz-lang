struct Lexer {
	// TODO: this should become an iterator or be byte indexed string instead of a list of chars
	source List(Char)
	errors List(Error)
	index  Int
}

fn new_lexer(source String) Lexer {
	Lexer(source: source.chars(), errors: [], index: 0)
}

fn next(mut lexer Lexer) Option(Token) {
	if lexer.source.len() <= lexer.index {
		none
	} else {
		let start = lexer.index
		let ch = lexer.curr()
		lexer.mut.advance()

		let kind = switch ch {
			'+' { add }
			'-' { sub }
			'*' { mul }
			'/' {
				switch lexer.curr() {
					'/' { panic("Comments not implemented yet") }
					_ { div }
				}
			}
			'%' { rem }
			'=' {
				switch lexer.curr() {
					'=' { lexer.mut.up(eq) }
					_  { assign }
				}
			}
			'<' {
				switch lexer.curr() {
					'=' { lexer.mut.up(le) }
					_ { lt }
				}
			}
			'>' {
				switch lexer.curr() {
					'=' { lexer.mut.up(ge) }
					_ { gt }
				}
			}
			'!' {
				switch lexer.curr() {
					'=' { lexer.mut.up(ne) }
					_ { not }
				}
			}
			'(' { lparen }
			')' { rparen }
			'[' { lbracket }
			']' { rbracket }
			'{' { lbrace }
			'}' { rbrace }
			',' { comma }
			'.' { dot }
			':' { colon }
			';' { semicolon }
			'|' { pipe }
			_ {
				if ch >= 'a' and ch <= 'z' {
					ident
				} else {
					error
				}
			}
		}

		let span = Span(start: start, end: lexer.index)
		Token(kind: kind, span: span)
	}
}

fn up(mut lexer Lexer, kind TokenKind) TokenKind {
	lexer.mut.advance()
	kind
}

fn advance(mut lexer Lexer) {
	lexer.index = lexer.index + 1
}

fn curr(mut lexer Lexer) Char {
	lexer.source[lexer.index]
}

fn peek(lexer Lexer) Char {
	lexer.source[lexer.index + 1]
}

fn peek(lexer Lexer, n Int) Char {
	lexer.source[lexer.index + n]
}
