struct ModuleStub {
    asts List(ast::Ast)
    path String
    name String
}

fn lower(asts List(ast::Ast)) Hir {
    var stubs = []
    for asts |ast| {
        stubs.mut.insert(ast)        
    }

    var hir = new_hir()
    var index = hir.mods.len()

    for stubs |stub| {
        let mod = new_module(stub.name)

        for stub.asts |ast| {
            for ast.items |item| {
                mod.mut.push_type(mut hir.types, item)
            }
        }

        hir.mut.push(mod)
    }

    // TODO: once pass for func signatures first maybe? or supply AST func signatures?
    for stubs |stub| {
        for stub.asts |ast| {
            for ast.items |item| {
                hir.mods[index].mut.push_func(mut hir.types, item)
            }
        }
        
        index += 1 
    }

    hir
}

fn insert(mut stubs List(ModuleStub), ast ast::Ast) {
    var index = 0 
    while index < stubs.len() {
        if stubs[index].path == ast.origin.mod_path() {
            stubs[index].asts ++= ast
            return
        }
        index += 1
    }

    stubs ++= ModuleStub(asts: [ast], path: ast.origin.mod_path(), name: ast.origin.mod_name())
}

fn mod_name(path String) String {
    let split = path.split('/')
    if split.len() < 2 { "" }

    split[split.len() - 2]
}

fn mod_path(path String) String {
    let split = path.split('/')
    var result = ""
    var index = 0
    while index < split.len() - 1 {
        result ++= split[index]
        result ++= '/'
        index += 1
    }

    result
}

test "Extract mod name from path" {
    assert "some/module/with/a/name/file.blitz".mod_name() == "name"
}

test "Extract mod path from path" {
    assert "this/is/a/module/with_a_file.blitz".mod_path() == "this/is/a/module/"
}

fn push_type(mut mod Module, mut types List(TypeKind), item ast::Definition) {
    // TODO: intern referenced types here
    switch item {
        ast::Pub { todo("HIR: pub") }
        ast::Struct { mod.mut.push(item.lower(mut types)) }
        ast::Union { mod.mut.push(item.lower(mut types)) }
        ast::Alias { mod.mut.push(item.lower(mut types)) }
        ast::Actor { mod.mut.push(item.lower(mut types)) }
        else {
            // tests and functions will be handled in a second pass later
        }
    }
}

fn push_func(mut mod Module, mut types List(TypeKind), item ast::Definition) {
    switch item {
        ast::Pub { todo("HIR: pub") }
        ast::Fn { mod.mut.push(item.lower(mut types)) }
        ast::Test { mod.mut.push(item.lower(mut types)) }
        else {
            // nothing to do, types should've already been pushed
        }
    }
}

fn lower(ty ast::Type, mut types List(TypeKind)) TypeRef {
    let chars = ty.name.chars()
    let result = if ty.params.len() == 0 and chars.len() == 1 {
        GenericId(letter: chars[0])
    } else {
        let args = for ty.params |param| {
            param.lower(mut types)
        }
        // TODO: find type definition and replace
        Nominal(def_id: TypeId(id: 0), args:)
    }
    types.mut.insert(result)    
}

fn lower(def ast::Struct, mut types List(TypeKind)) TypeDef {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)
    var fields = []
    for def.fields |field| {
        fields ++= FieldDef(name: field.name, type: TypeRef(id: 0))
    }

    // TODO: type parameters
    TypeDef(name:, generic: [], kind: StructDef(fields:), vis: module)
}

fn lower(def ast::Union, mut types List(TypeKind)) TypeDef {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)
    let kind = UnionDef(label: none, type: TypeRef(id: 0))

    // TODO: type parameters
    TypeDef(name:, generic: [], kind:, vis: module)
}

fn lower(def ast::Fn, mut types List(TypeKind)) FuncDef {
    let name = def.name
    var params = []
    for def.args |arg| {
        params ++= TypeRef(id: 0)
    }

    // TODO: type parameters
    // TODO: lower expressions
    FuncDef(name:, module: ModId(id: 0), generic: [], params:, result: TypeRef(id: 0), body: Body(expressions: []), vis: module)
}

fn lower(def ast::Alias, mut types List(TypeKind)) TypeDef {
    todo("HIR: alias")
}

fn lower(def ast::Actor, mut types List(TypeKind)) TypeDef {
    todo("HIR: actor")
}

fn lower(def ast::Test, mut types List(TypeKind)) FuncDef {
    todo("HIR: test")
}
