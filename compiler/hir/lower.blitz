struct ModuleStub {
    asts List(Ast)
    path String
    name String
}

fn lower(asts List(Ast)) Hir {
    var stubs = []
    // TODO: yet another pass where stubs for all types are created first
    // TODO: maybe pre-sort ASTs by module name already
    for asts |ast| {
        stubs.mut.insert(ast)        
    }

    var hir = new_hir()

    // TODO: this stuff is outdated, iterate over the module stubs
    for asts |ast| {
        let name = ast.origin.mod_name()
        let index = hir.find(name) else {
            let mod = new_module(name)
            hir.mut.push(mod)
        }

        for ast.items |item| {
            hir.mods[index.id].mut.push_type(mut hir.types, item)
        }
    }

    for asts |ast| {
        let name = ast.origin.mod_name()
        let index = hir.find(name) else {
            panic("All modules should have been pushed in the first pass!")
            // HACK: this is never reachable, but the bootstrap compiler typechecking currently cannot handle diverging types
            ModId(id: 0)
        }

        for ast.items |item| {
            hir.mods[index.id].mut.push_func(mut hir.types, item)
        }
    }

    hir
}

fn insert(mut stubs List(ModuleStub), ast Ast) {
    var index = 0 
    while index < stubs.len() {
        if stubs[index].path == ast.origin.mod_path() {
            stubs[index].asts ++= ast
            return
        }
        index += 1
    }

    stubs ++= ModuleStub(asts: [ast], path: ast.origin.mod_path(), name: ast.origin.mod_name())
}

fn mod_name(path String) String {
    let split = path.split('/')
    if split.len() < 2 { "" }

    split[split.len() - 2]
}

fn mod_path(path String) String {
    let split = path.split('/')
    var result = ""
    var index = 0
    while index < split.len() - 1 {
        result ++= split[index]
        result ++= '/'
        index += 1
    }

    result
}

test "Extract mod name from path" {
    assert "some/module/with/a/name/file.blitz".mod_name() == "name"
}

test "Extract mod path from path" {
    assert "this/is/a/module/with_a_file.blitz".mod_path() == "this/is/a/module/"
}

fn push_type(mut mod Module, mut types List(TypeKind), item Definition) {
    // TODO: intern referenced types here
    switch item {
        Pub { todo("HIR: pub") }
        Struct { mod.mut.push(item.lower(mut types)) }
        Union { mod.mut.push(item.lower(mut types)) }
        Alias { mod.mut.push(item.lower(mut types)) }
        Actor { mod.mut.push(item.lower(mut types)) }
        else {
            // tests and functions will be handled in a second pass later
        }
    }
}

fn push_func(mut mod Module, mut types List(TypeKind), item Definition) {
    switch item {
        Pub { todo("HIR: pub") }
        Fn { mod.mut.push(item.lower(mut types)) }
        Test { mod.mut.push(item.lower(mut types)) }
        else {
            // nothing to do, types should've already been pushed
        }
    }
}

fn lower(ty Type, mut types List(TypeKind)) TypeRef {
    let chars = ty.name.chars()
    let result = if ty.params.len() == 0 and chars.len() == 1 {
        GenericId(letter: chars[0])
    } else {
        let args = for ty.params |param| {
            param.lower(mut types)
        }
        // TODO: find type definition and replace
        Nominal(def_id: TypeId(id: 0), args:)
    }
    types.mut.insert(result)    
}

fn lower(def Struct, mut types List(TypeKind)) TypeDef {
    let name = Ident(name: def.sig.name, span: def.sig.span)
    var fields = []
    for def.fields |field| {
        fields ++= FieldDef(name: field.name, type: TypeRef(id: 0))
    }

    // TODO: type parameters
    TypeDef(name:, generic: [], kind: StructDef(fields:), vis: module)
}

fn lower(def Union, mut types List(TypeKind)) TypeDef {
    let name = Ident(name: def.sig.name, span: def.sig.span)
    let kind = UnionDef(label: none, type: TypeRef(id: 0))

    // TODO: type parameters
    TypeDef(name:, generic: [], kind:, vis: module)
}

fn lower(def Fn, mut types List(TypeKind)) FuncDef {
    let name = def.name
    var params = []
    for def.args |arg| {
        params ++= TypeRef(id: 0)
    }

    // TODO: type parameters
    // TODO: lower expressions
    FuncDef(name:, module: ModId(id: 0), generic: [], params:, result: TypeRef(id: 0), body: HirBody(expressions: []), vis: module)
}

fn lower(def Alias, mut types List(TypeKind)) TypeDef {
    todo("HIR: alias")
}

fn lower(def Actor, mut types List(TypeKind)) TypeDef {
    todo("HIR: actor")
}

fn lower(def Test, mut types List(TypeKind)) FuncDef {
    todo("HIR: test")
}
