struct ModuleStub {
    asts List(ast::Ast)
    path String
    name String
}

fn lower(asts List(ast::Ast)) Hir {
    var stubs = []
    for asts |ast| {
        stubs.mut.insert(ast)        
    }

    var hir = new_hir()
    var index = hir.mods.len()

    for stubs |stub| {
        let mod = new_module(stub.name)

        for stub.asts |ast| {
            for ast.items |item| {
                mod.mut.push_sig(mut hir.types, item)
            }
        }

        hir.mut.push(mod)
    }

    for stubs |stub| {
        for stub.asts |ast| {
            for ast.items |item| {
                hir.mods[index].mut.push(mut hir.types, item)
            }
        }
        
        index += 1 
    }

    hir
}

fn insert(mut stubs List(ModuleStub), ast ast::Ast) {
    var index = 0 
    while index < stubs.len() {
        if stubs[index].path == ast.origin.mod_path() {
            stubs[index].asts ++= ast
            return
        }
        index += 1
    }

    stubs ++= ModuleStub(asts: [ast], path: ast.origin.mod_path(), name: ast.origin.mod_name())
}

fn mod_name(path String) String {
    let split = path.split('/')
    if split.len() < 2 { "" }

    split[split.len() - 2]
}

fn mod_path(path String) String {
    let split = path.split('/')
    var result = ""
    var index = 0
    while index < split.len() - 1 {
        result ++= split[index]
        result ++= '/'
        index += 1
    }

    result
}

fn push_sig(mut mod Module, item ast::Definition) {
    switch item {
        ast::Pub { todo("HIR: pub") }
        ast::Struct { mod.mut.push(item.sig()) }
        ast::Union { mod.mut.push(item.sig()) }
        ast::Alias { mod.mut.push(item.sig()) }
        ast::Actor { mod.mut.push(item.sig()) }
        ast::Pub { todo("HIR: pub") }
        ast::Fn { mod.mut.push(item.sig()) }
        ast::Test { mod.mut.push(item.sig()) }
    }
}

fn sig(def ast::Struct, mut types List(TypeKind)) TypeDef {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)

    // TODO: type parameters
    TypeDef(name:, generic: [], kind: StructDef(fields: []), vis: module)
}

fn sig(def ast::Union, mut types List(TypeKind)) TypeDef {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)

    // TODO: type parameters
    TypeDef(name:, generic: [], kind: UnionDef(cases: []), vis: module)
}

fn sig(def ast::Fn, mut types List(TypeKind)) FuncDef {
    FuncDef(name: def.name, generic: [], params: [], result: none, body: Body(expressions: []), vis: module)
}

fn sig(def ast::Alias, mut types List(TypeKind)) TypeDef {
    todo("HIR: alias")
}

fn sig(def ast::Actor, mut types List(TypeKind)) TypeDef {
    todo("HIR: actor")
}

fn sig(def ast::Test, mut types List(TypeKind)) FuncDef {
    todo("HIR: test")
}

fn push(mut mod Module, mut types List(TypeKind), item ast::Definition) {
    switch item {
        ast::Pub { todo("HIR: pub") }
        ast::Struct { mod.mut.push(item.lower(mut types)) }
        ast::Union { mod.mut.push(item.lower(mut types)) }
        ast::Alias { mod.mut.push(item.lower(mut types)) }
        ast::Actor { mod.mut.push(item.lower(mut types)) }
        ast::Pub { todo("HIR: pub") }
        ast::Fn { mod.mut.push(item.lower(mut types)) }
        ast::Test { mod.mut.push(item.lower(mut types)) }
    }
}

fn lower(ty ast::Type, mut types List(TypeKind)) TypeRef {
    let chars = ty.name.chars()
    let result = if ty.params.len() == 0 and chars.len() == 1 {
        GenericId(letter: chars[0])
    } else {
        let args = for ty.params |param| {
            param.lower(mut types)
        }
        // TODO LLM: find type definition and replace
        Nominal(def_id: TypeId(id: 0), args:)
    }
    types.mut.insert(result)    
}


// TODO LLM: These lower functions should take the relevant module, find and update the already existing stub of the type or function (these stubs will only contain the name and be in the correct module so far) and edit that instead of returning something new
fn lower(def ast::Struct, mut types List(TypeKind)) TypeDef {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)
    var fields = []
    for def.fields |field| {
        fields ++= FieldDef(name: field.name, type: TypeRef(id: 0))
    }

    // TODO: type parameters
    TypeDef(name:, generic: [], kind: StructDef(fields:), vis: module)
}

fn lower(def ast::Union, mut types List(TypeKind)) TypeDef {
    let name = ast::Ident(name: def.sig.name, span: def.sig.span)
    let kind = UnionDef(label: none, type: TypeRef(id: 0))

    // TODO: type parameters
    TypeDef(name:, generic: [], kind:, vis: module)
}

fn lower(def ast::Fn, mut types List(TypeKind)) FuncDef {
    let name = def.name
    var params = []
    for def.args |arg| {
        // TODO LLM: find type id in hir. since there is no unqualified use, finding out the correct module should be rather straighforward (if unqualified, it is either this module or std or core)
        params ++= TypeRef(id: 0)
    }

    // TODO: type parameters
    // TODO: lower expressions
    // TODO LLM: find the existing definition stub here and update it
    FuncDef(name:, module:, generic: [], params:, result: TypeRef(id: 0), body: Body(expressions: []), vis: module)
}

fn lower(def ast::Alias, mut types List(TypeKind)) TypeDef {
    todo("HIR: alias")
}

fn lower(def ast::Actor, mut types List(TypeKind)) TypeDef {
    todo("HIR: actor")
}

fn lower(def ast::Test, mut types List(TypeKind)) FuncDef {
    todo("HIR: test")
}
