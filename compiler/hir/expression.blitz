struct Body {
	expressions List(Expression) // arena indexed by ExpressionId
}

struct ExpressionId {
	id Int
}

fn get(body Body, id ExpressionId) Expression {
	body.expressions[id.id]
}

fn push(mut body Body, expr Expression) ExpressionId {
	body.expressions ++= expr
	ExpressionId(id: body.expressions.len() - 1)
}

struct Expression {
	kind ExpressionKind
	span ast::Span
}

union ExpressionKind {
	// Literals
	LitInt
	LitFloat
	LitString
	LitRune

	// Variable reference (resolved to a local binding)
	LocalRef

	// Operations
	BinaryOp
	UnaryOp

	// Calls â€” candidates are resolved by name; the type checker selects one
	Call
	Constructor

	// Access
	Member
	Index

	// Control flow
	If
	While
	For
	Switch
	Block
	Return
	Break
	Continue

	// Declarations (live in the body arena alongside expressions)
	Let

	// Assignment
	Assign

	// Special
	Assert
	Mut
	Try
	ListLit
	Group
}

// --- Literals ---
// TODO: make these generic types

struct LitInt {
	value Int
}

struct LitFloat {
	value Float
}

struct LitString {
	value String
}

struct LitRune {
	value Rune
}

// --- Variable reference ---

struct LocalRef {
	name       ast::Ident
	binding_id Int // unique ID assigned when the binding was declared
}

// --- Operations ---

struct BinaryOp {
	op    ast::BinaryOperator
	left  ExpressionId
	right ExpressionId
}

struct UnaryOp {
	op   ast::UnaryOperator
	expr ExpressionId
}

// --- Calls ---

// Regular call: func(args) or module::func(args)
// candidates is populated by the resolver and narrowed by the type checker.
struct Call {
	name       ast::Ident
	module     Option(ast::Ident) // qualified module if present
	candidates List(FuncId)
	args       List(Argument)
}
struct Argument {
	label Option(ast::Ident)
	value ExpressionId
}

// Constructor call: Type(field: value, ...)
struct Constructor {
	type_id    TypeId
	type_name  ast::Ident  // kept for diagnostics
	args       List(FieldInit)
}

struct FieldInit {
	label Option(ast::Ident)
	value ExpressionId
}

// --- Access ---

struct Member {
	expr  ExpressionId
	field ast::Ident
}

struct Index {
	target ExpressionId
	index  ExpressionId
}

// --- Control flow ---

struct If {
	cond      ExpressionId
	then_body ExpressionId
	else_body Option(ExpressionId)
}

struct While {
	cond ExpressionId
	body ExpressionId
}

struct For {
	iter    ExpressionId
	binding ast::Ident
	body    ExpressionId
}

struct Switch {
	cond  ExpressionId
	cases List(SwitchCase)
}

struct SwitchCase {
	label SwitchLabel
	body  ExpressionId
	span  ast::Span
}

union SwitchLabel {
	TypeCase
	IdentCase
	LiteralCase
	// TODO LLM: it should work to call this default, unfortunately the bootstrap compiler codegen chokes on it (maybe because the name exists elsewhere), please fix the underlying issue
	defaultCase
}

struct TypeCase {
	type_id   TypeId
	type_name ast::Ident // kept for diagnostics
}

struct IdentCase {
	name ast::Ident
}

struct LiteralCase {
	value ExpressionId
}

struct Block {
	stmts List(ExpressionId)
}

struct Return {
	expr Option(ExpressionId)
}

struct Break {}

struct Continue {}

// --- Declarations ---

struct Let {
	name    ast::Ident
	type_   Option(TypeRef)  // explicit type annotation if present
	init    ExpressionId
	is_mut  Bool
	binding_id Int           // unique ID assigned by the scope tracker
}

// --- Assignment ---

struct Assign {
	target ExpressionId
	value  ExpressionId
}

// --- Special ---

struct Assert {
	cond ExpressionId
}

struct Mut {
	expr ExpressionId
}

struct Try {
	expr ExpressionId
}

struct ListLit {
	elems List(ExpressionId)
}

struct Group {
	expr ExpressionId
}
