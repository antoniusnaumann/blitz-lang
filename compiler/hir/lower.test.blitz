test "New HIR contains core module" {
    let hir = new_hir()
    assert hir.mods.len() == 1

    let mod_id = hir.find("core")
    assert mod_id != none
    assert hir.get(mod_id.unwrap()).name == "core"
}

test "Create module name from AST" {
    let ast = ast::Ast(origin: "some/mymodule/file.blitz", items: [])
    var asts = []
    asts ++= ast
    let hir = asts.lower()
    
    // Should create a module named "mymodule" (plus core module = 2 total)
    assert hir.mods.len() == 2
    
    let mod_id = hir.find("mymodule")
    assert mod_id != none
    
    let mod = hir.get(mod_id.unwrap())
    assert mod.name == "mymodule"
}

test "Collect ASTs into module" {
    // Multiple files in same directory should go to same module
    let fn1 = ast::Fn(
        name: ast::Ident(name: "add", span: ast::empty_span()),
        args: [],
        type: none,
        body: ast::Block(statements: [], span: ast::empty_span()),
        span: ast::empty_span()
    )
    var items1 = []
    items1 ++= fn1
    let ast1 = ast::Ast(origin: "src/math/add.blitz", items: items1)
    
    let fn2 = ast::Fn(
        name: ast::Ident(name: "subtract", span: ast::empty_span()),
        args: [],
        type: none,
        body: ast::Block(statements: [], span: ast::empty_span()),
        span: ast::empty_span()
    )
    var items2 = []
    items2 ++= fn2
    let ast2 = ast::Ast(origin: "src/math/subtract.blitz", items: items2)
    
    var asts = []
    asts ++= ast1
    asts ++= ast2
    let hir = asts.lower()
    
    // Should have only one "math" module (plus core) = 2 total
    assert hir.mods.len() == 2
    
    let mod_id = hir.find("math")
    assert mod_id != none
    
    let mod = hir.get(mod_id.unwrap())
    assert mod.funcs.len() == 2
}

test "Create module names from ASTs" {
    let ast1 = ast::Ast(origin: "src/module1/file.blitz", items: [])
    let ast2 = ast::Ast(origin: "src/module2/file.blitz", items: [])
    let ast3 = ast::Ast(origin: "src/module3/file.blitz", items: [])
    
    var asts = []
    asts ++= ast1
    asts ++= ast2
    asts ++= ast3
    let hir = asts.lower()
    
    // Should have 3 modules + core = 4 total
    assert hir.mods.len() == 4
    assert hir.find("module1") != none
    assert hir.find("module2") != none
    assert hir.find("module3") != none
}

test "Lower types" {
    let struct_def = ast::Struct(
        sig: ast::Type(name: "Point", params: [], span: ast::empty_span(), module: none),
        fields: [
            ast::Field(
                name: ast::Ident(name: "x", span: ast::empty_span()),
                type: ast::Type(name: "Int", params: [], span: ast::empty_span(), module: none),
                span: ast::empty_span()
            ),
            ast::Field(
                name: ast::Ident(name: "y", span: ast::empty_span()),
                type: ast::Type(name: "Int", params: [], span: ast::empty_span(), module: none),
                span: ast::empty_span()
            )
        ],
        span: ast::empty_span()
    )
    
    var items = []
    items ++= struct_def
    let ast = ast::Ast(origin: "src/geometry/point.blitz", items:)
    var asts = []
    asts ++= ast
    let hir = asts.lower()
    
    let mod_id = hir.find("geometry")
    assert mod_id != none
    
    let mod = hir.get(mod_id.unwrap())
    assert mod.types.len() == 1
    
    let type_def = mod.types[0]
    assert type_def.name.name == "Point"
    
    switch type_def.kind {
        StructDef { 
            assert it.fields.len() == 2
        }
        else { panic("Expected StructDef") }
    }
}

test "Extract mod name from path" {
    assert "some/module/with/a/name/file.blitz".mod_name() == "name"
}

test "Extract mod path from path" {
    assert "this/is/a/module/with_a_file.blitz".mod_path() == "this/is/a/module/"
}

