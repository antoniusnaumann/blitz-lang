struct Hir {
    mods  List(Module) // indexed by ModId
    types List(TypeKind) // fully qualified, indexed by TypeRef 
}

fn new_hir() Hir {
    let core_types = [
        define_builtin("Void"),
        define_builtin("Int"),
        define_builtin("Float"),
    ]
    let core_module = Module(id: core_mod_id(), name: "core", funcs: [], types: [], func_export: [], type_export: [])
    // TODO: insert builtin types as part of the "core" module

    Hir(mods: [core_module], types: [])
}

fn core_mod_id() ModId {
    ModId(id: 0)
}

fn void_type() TypeRef {
    TypeRef(id: 0)
}

fn get(reg Hir, name String) Option(Module) {
    // TODO: HashMap lookup
    for reg.mods |it| {
        if it.name == name { return it }
    }

    none
}

fn find(reg Hir, name String) Option(ModId) {
    var index = 0
    while index < reg.mods.len() {
        let item = reg.mods[index]
        if item.name == name { return ModId(id: index) }
        index += 1
    }
    
    none
}

fn find(reg Hir, type TypeKind) Option(TypeRef) {
    reg.types.find(type)
}

fn find(types List(TypeKind), type TypeKind) Option(TypeRef) {
    var index = 0
    while index < types.len() {
        let item = types[index]
        if item == type { return TypeRef(id: index) }
        index += 1
    }

    none
}

fn get(reg Hir, mod ModId) Module {
    reg.mods[mod.id]
}

fn get(mods List(Module), mod ModId) Module {
    mods[mod.id]
}

fn get(reg Hir, ty TypeRef) TypeKind {
    reg.types[ty.id]
}

fn get(types List(TypeKind), ty TypeRef) TypeKind {
    types[ty.id]
}

fn push(mut reg Hir, mod Module) ModId {
    reg.mods.mut.push(mod)
}

fn push(mut mods List(Module), mod Module) ModId {
    mods ++= mod
    ModId(id: mods.len() - 1)
}

fn push(mut reg Hir, ty TypeKind) TypeRef {
    reg.types.mut.push(ty)
}

fn push(mut types List(TypeKind), ty TypeKind) TypeRef {
    types ++= ty
    TypeRef(id: types.len() - 1)
}

fn insert(mut types List(TypeKind), ty TypeKind) TypeRef {
    types.find(ty) else { types.mut.push(ty) }
}

union TypeKind {
    Nominal
    GenericId
}

struct Nominal {
    def_id TypeId
    args   List(TypeRef)
}

struct Module {
   id     ModId
   name   String
   // parent Option(ModId)
   // childs List(ModId) 
   funcs  List(FuncDef)  // indexed by FuncId
   types  List(TypeDef)  // indexed by TypeId

   func_export List(FuncId)
   type_export List(TypeId)
}

fn new_module(name String, id ModId) Module {
    Module(id:, name:, funcs: [], types: [], func_export: [], type_export: [])
}

fn find_type(mod Module, name String) Option(TypeId) {
    var index = 0
    while index < mod.types.len() {
        if mod.types[index].name.name == name { return TypeId(module: mod.id, id: index) }
        index += 1
    }
    none
}

fn find_func(mod Module, name String) Option(FuncId) {
    var index = 0
    while index < mod.funcs.len() {
        if mod.funcs[index].name.name == name { return FuncId(module: mod.id, id: index) }
        index += 1
    }
    none
}

fn find_type(hir Hir, name String) Option(TypeId) {
    var mod_index = 0
    while mod_index < hir.mods.len() {
        let mod = hir.mods[mod_index]
        let result = mod.find_type(name)
        if result != none {
            let type_id = result.unwrap()
            return TypeId(module: ModId(id: mod_index), id: type_id.id)
        }
        mod_index += 1
    }
    none
}

fn find_type(hir Hir, mod_id ModId, name String) Option(TypeId) {
    let mod = hir.get(mod_id)
    let result = mod.find_type(name)
    if result != none {
        let type_id = result.unwrap()
        return TypeId(module: mod_id, id: type_id.id)
    }
    none
}

fn push(mut mod Module, def FuncDef) FuncId {
    mod.funcs ++= def
    FuncId(module: mod.id, id: mod.funcs.len() - 1)
}

fn push(mut mod Module, def TypeDef) TypeId {
    mod.types ++= def
    TypeId(module: mod.id, id: mod.types.len() - 1)
}

fn set_type(mut mod Module, id Int, def TypeDef) {
    mod.types[id] = def
}

fn set_func(mut mod Module, id Int, def FuncDef) {
    mod.funcs[id] = def
}

struct TypeDef {
    name    ast::Ident
    generic List(GenericId)
    kind    TypeDefKind
    vis     Visibility
}

union TypeDefKind {
    StructDef
    UnionDef
    builtin
}

fn define_builtin(name String) TypeDef {
    TypeDef(name: name.ident(), generic: [], kind: builtin, vis: public)
}

struct StructDef {
    fields List(FieldDef)
}

struct FieldDef {
    name ast::Ident
    type TypeRef
}

struct UnionDef {
    cases List(CaseDef)
}

struct CaseDef {
    label Option(ast::Ident)
    type  TypeRef
}

struct FuncDef {
    name    ast::Ident
    generic List(GenericId)
    params  List(TypeRef)
    result  TypeRef
    body    Body              
    vis     Visibility
}

struct GenericId {
    letter Rune // take advantage of the fact that type params are always single letter
}

struct FuncId {
    module ModId
    id     Int
}

struct TypeId {
    module ModId
    id     Int 
}

struct ModId {
    id Int
}

struct TypeRef {
    id Int
}

union Visibility {
    public
    module
}
