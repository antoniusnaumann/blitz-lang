struct Hir {
    mods  List(Module) // indexed by ModId
    types List(TypeKind) // fully qualified, indexed by TypeRef 
}

fn new_hir() Hir {
    let core_module = Module(name: "core", funcs: [], types: [], func_export: [], type_export: [])
    // TODO: insert builtin types as part of the "core" module

    Hir(mods: [core_module], types: [])
}

fn get(reg Hir, name String) Option(Module) {
    // TODO: HashMap lookup
    for reg.mods |it| {
        if it.name == name { return it }
    }

    none
}

fn find(reg Hir, name String) Option(ModId) {
    mut index = 0
    while index < reg.mods.len() {
        let item = reg.mods[index]
        if item.name == name { return ModId(id: index) }
        index += 1
    }
    
    none
}

fn find(reg Hir, type TypeKind) Option(TypeRef) {
    reg.types.find(type)
}

fn find(types List(TypeKind), type TypeKind) Option(TypeRef) {
    mut index = 0
    while index < types.len() {
        let item = types[index]
        if item == type { return TypeRef(id: index) }
        index += 1
    }

    none
}

fn get(reg Hir, mod ModId) Module {
    reg.mods[mod.id]
}

fn get(mods List(Module), mod ModId) Module {
    mods[mod.id]
}

fn get(reg Hir, ty TypeRef) TypeKind {
    reg.types[ty.id]
}

fn get(types List(TypeKind), ty TypeRef) TypeKind {
    types[ty.id]
}

fn push(mut reg Hir, mod Module) ModId {
    reg.mods.mut.push(mod)
}

fn push(mut mods List(Module), mod Module) ModId {
    mods ++= mod
    ModId(id: mods.len() - 1)
}

fn push(mut reg Hir, ty TypeKind) TypeRef {
    reg.types.mut.push(ty)
}

fn push(mut types List(TypeKind), ty TypeKind) TypeRef {
    types ++= ty
    TypeRef(id: types.len() - 1)
}

fn insert(mut types List(TypeKind), ty TypeKind) TypeRef {
    types.find(ty) else { types.mut.push(ty) }
}

union TypeKind {
    Nominal
    GenericId
}

struct Nominal {
    def_id TypeId
    args   List(TypeRef)
}

struct TypeParam {
    local_id Int
}

struct Module {
   name   String
   // parent Option(ModId)
   // childs List(ModId) 
   funcs  List(FuncDef)  // indexed by FuncId
   types  List(TypeDef)  // indexed by TypeId

   func_export List(FuncId)
   type_export List(TypeId)
}

fn new_module(name String) Module {
    Module(name:, funcs: [], types: [], func_export: [], type_export: [])
}

fn push(mut mod Module, def FuncDef) FuncId {
    mod.funcs ++= def
    FuncId(module: def.module, id: mod.funcs.len() - 1)
}

fn push(mut mod Module, def TypeDef) TypeId {
    mod.types ++= def
    TypeId(module: ModId(id: 0), id: mod.types.len() - 1)
}

struct TypeDef {
    name    Ident
    generic List(TypeParam)
    kind    TypeDefKind
    vis     Visibility
}

union TypeDefKind {
    StructDef
    UnionDef
}

struct StructDef {
    fields List(FieldDef)
}

struct FieldDef {
    name Ident
    type TypeRef
}

struct UnionDef {
    label Option(Ident)
    type  TypeRef
}

struct FuncDef {
    name    Ident
    module  ModId            
    generic List(GenericId)
    params  List(TypeRef)
    result  TypeRef
    body    HirBody              
    vis     Visibility
}

struct GenericId {
    letter Rune // take advantage of the fact that type params are always single letter
}

struct FuncId {
    module ModId
    id     Int
}

struct TypeId {
    module ModId
    id     Int 
}

struct ModId {
    id Int
}

struct TypeRef {
    id Int
}

union Visibility {
    public
    module
}
